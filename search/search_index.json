{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Waldiez","text":""},{"location":"#waldiez","title":"Waldiez","text":"<p>Translate a Waldiez flow:</p> <p> </p> <p>To a python script or a jupyter notebook with the corresponding ag2 agents and chats.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Convert .waldiez flows to .py or .ipynb</li> <li>Run a .waldiez flow</li> <li>Store the runtime logs of a flow to csv for further analysis</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>On PyPI:</p> <pre><code>python -m pip install waldiez\n</code></pre> <p>From the repository:</p> <pre><code>python -m pip install git+https://github.com/waldiez/python.git\n</code></pre> <p>Note</p> <p><code>autogen-agentchat</code> package conflicts with <code>ag2</code> / <code>pyautogen</code>. Ensure that <code>autogen-agentchat</code> is uninstalled before installing <code>waldiez</code>. If you have already installed <code>autogen-agentchat</code>, you can uninstall it with the following command:</p> <pre><code>```shell\npip uninstall autogen-agentchat -y\n```\n\nIf already installed waldiez you might need to reinstall it after uninstalling `autogen-agentchat`:\n\n```shell\npip install --force --no-cache waldiez pyautogen\n```\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#cli","title":"CLI","text":"<pre><code># Convert a Waldiez flow to a python script or a jupyter notebook\nwaldiez convert --file /path/to/a/flow.waldiez --output /path/to/an/output/flow[.py|.ipynb]\n# Convert and run the script, optionally force generation if the output file already exists\nwaldiez run --file /path/to/a/flow.waldiez --output /path/to/an/output/flow[.py] [--force]\n</code></pre>"},{"location":"#using-dockerpodman","title":"Using docker/podman","text":"<pre><code>CONTAINER_COMMAND=docker # or podman\n# pull the image\n$CONTAINER_COMMAND pull waldiez/waldiez\n# Convert a Waldiez flow to a python script or a jupyter notebook\n$CONTAINER_COMMAND run \\\n  --rm \\\n  -v /path/to/a/flow.waldiez:/flow.waldiez \\\n  -v /path/to/an/output:/output \\\n  waldiez/waldiez convert --file /flow.waldiez --output /output/flow[.py|.ipynb] [--force]\n\n# with selinux and/or podman, you might get permission (or file not found) errors, so you can try:\n$CONTAINER_COMMAND run \\\n  --rm \\\n  -v /path/to/a/flow.waldiez:/flow.waldiez \\\n  -v /path/to/an/output:/output \\\n  --userns=keep-id \\\n  --security-opt label=disable \\\n  waldiez/waldiez convert --file /flow.waldiez --output /output/flow[.py|.ipynb] [--force]\n</code></pre> <pre><code># Convert and run the script\n$CONTAINER_COMMAND run \\\n  --rm \\\n  -v /path/to/a/flow.waldiez:/flow.waldiez \\\n  -v /path/to/an/output:/output \\\n  waldiez/waldiez run --file /flow.waldiez --output /output/output[.py]\n</code></pre>"},{"location":"#ui","title":"UI","text":"<p>For creating-only (no exporting or running) waldiez flows, you can use the playground at https://waldiez.github.io. The repo for the js library is here. We are currently working on waldiez-studio to provide a visual interface for creating and running Waldiez flows (you can find more here). Until then, you can use our Jupyter or the VSCode extension to create and run Waldiez flows.</p>"},{"location":"#as-a-library","title":"As a library","text":""},{"location":"#export-a-flow","title":"Export a flow","text":"<pre><code># Export a Waldiez flow to a python script or a jupyter notebook\nfrom waldiez import WaldiezExporter\nflow_path = \"/path/to/a/flow.waldiez\"\noutput_path = \"/path/to/an/output.py\"  # or .ipynb\nexporter = WaldiezExporter.load(flow_path)\nexporter.export(output_path)\n</code></pre>"},{"location":"#run-a-flow","title":"Run a flow","text":"<pre><code># Run a flow\nfrom waldiez import WaldiezRunner\nflow_path = \"/path/to/a/flow.waldiez\"\noutput_path = \"/path/to/an/output.py\"\nrunner = WaldiezRunner.load(flow_path)\nrunner.run(output_path=output_path)\n</code></pre>"},{"location":"#tools","title":"Tools","text":"<ul> <li>ag2 (formerly AutoGen)</li> <li>juptytext</li> <li>pydantic</li> <li>typer</li> <li>asyncer</li> </ul>"},{"location":"exporter/","title":"WaldiezExporter","text":"<p>The role of the exporter is to export the model's data to an autogen's flow with one or more chats.</p> <p>The resulting file(s): a <code>flow.py</code> file with one <code>main()</code> function to trigger the chat(s).</p>"},{"location":"exporter/#waldiez.exporter.WaldiezExporter","title":"<code>WaldiezExporter(waldiez: Waldiez)</code>","text":"<p>Waldiez exporter.</p> <p>Attributes:     waldiez (Waldiez): The Waldiez instance.</p> <p>Parameters:     waldiez (Waldiez): The Waldiez instance.</p> Source code in <code>waldiez/exporter.py</code> <pre><code>def __init__(self, waldiez: Waldiez) -&gt; None:\n    \"\"\"Initialize the Waldiez exporter.\n\n    Parameters:\n        waldiez (Waldiez): The Waldiez instance.\n    \"\"\"\n    self.waldiez = waldiez\n</code></pre>"},{"location":"exporter/#waldiez.exporter.WaldiezExporter.export","title":"<code>export(path: Union[str, Path], force: bool = False) -&gt; None</code>","text":"<p>Export the Waldiez instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to export to.</p> required <code>force</code> <code>bool</code> <p>Override the output file if it already exists, by default False.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file already exists and force is False.</p> <code>IsADirectoryError</code> <p>If the output is a directory.</p> <code>ValueError</code> <p>If the file extension is invalid.</p> Source code in <code>waldiez/exporter.py</code> <pre><code>def export(self, path: Union[str, Path], force: bool = False) -&gt; None:\n    \"\"\"Export the Waldiez instance.\n\n    Parameters\n    ----------\n    path : Union[str, Path]\n        The path to export to.\n    force : bool, optional\n        Override the output file if it already exists, by default False.\n\n    Raises\n    ------\n    FileExistsError\n        If the file already exists and force is False.\n    IsADirectoryError\n        If the output is a directory.\n    ValueError\n        If the file extension is invalid.\n    \"\"\"\n    if not isinstance(path, Path):\n        path = Path(path)\n    path = path.resolve()\n    if path.is_dir():\n        raise IsADirectoryError(f\"Output is a directory: {path}\")\n    if path.exists():\n        if force is False:\n            raise FileExistsError(f\"File already exists: {path}\")\n        path.unlink(missing_ok=True)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    extension = path.suffix\n    if extension == \".waldiez\":\n        self.to_waldiez(path)\n    elif extension == \".py\":\n        self.to_py(path)\n    elif extension == \".ipynb\":\n        self.to_ipynb(path)\n    else:\n        raise ValueError(f\"Invalid extension: {extension}\")\n</code></pre>"},{"location":"exporter/#waldiez.exporter.WaldiezExporter.load","title":"<code>load(file_path: Path) -&gt; WaldiezExporter</code>  <code>classmethod</code>","text":"<p>Load the Waldiez instance from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The file path.</p> required <p>Returns:</p> Type Description <code>WaldiezExporter</code> <p>The Waldiez exporter.</p> Source code in <code>waldiez/exporter.py</code> <pre><code>@classmethod\ndef load(cls, file_path: Path) -&gt; \"WaldiezExporter\":\n    \"\"\"Load the Waldiez instance from a file.\n\n    Parameters\n    ----------\n    file_path : Path\n        The file path.\n\n    Returns\n    -------\n    WaldiezExporter\n        The Waldiez exporter.\n    \"\"\"\n    waldiez = Waldiez.load(file_path)\n    return cls(waldiez)\n</code></pre>"},{"location":"exporter/#waldiez.exporter.WaldiezExporter.to_ipynb","title":"<code>to_ipynb(path: Path) -&gt; None</code>","text":"<p>Export flow to jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to export to.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the notebook could not be generated.</p> Source code in <code>waldiez/exporter.py</code> <pre><code>def to_ipynb(self, path: Path) -&gt; None:\n    \"\"\"Export flow to jupyter notebook.\n\n    Parameters\n    ----------\n    path : Path\n        The path to export to.\n\n    Raises\n    ------\n    RuntimeError\n        If the notebook could not be generated.\n    \"\"\"\n    # we first create a .py file with the content\n    # and then convert it to a notebook using jupytext\n    exporter = FlowExporter(\n        waldiez=self.waldiez,\n        output_dir=path.parent,\n        for_notebook=True,\n    )\n    output = exporter.export()\n    content = output[\"content\"]\n    if not content:\n        raise RuntimeError(\"Could not generate notebook\")\n    py_path = path.with_suffix(\".tmp.py\")\n    with open(py_path, \"w\", encoding=\"utf-8\", newline=\"\\n\") as f:\n        f.write(content)\n    with open(py_path, \"r\", encoding=\"utf-8\") as py_out:\n        content = jupytext.read(py_out, fmt=\"py:light\")\n    ipynb_path = str(py_path).replace(\".tmp.py\", \".tmp.ipynb\")\n    jupytext.write(content, ipynb_path, fmt=\"ipynb\")\n    Path(ipynb_path).rename(ipynb_path.replace(\".tmp.ipynb\", \".ipynb\"))\n    py_path.unlink(missing_ok=True)\n</code></pre>"},{"location":"exporter/#waldiez.exporter.WaldiezExporter.to_py","title":"<code>to_py(path: Path) -&gt; None</code>","text":"<p>Export waldiez flow to python script.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to export to.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the python script could not be generated.</p> Source code in <code>waldiez/exporter.py</code> <pre><code>def to_py(self, path: Path) -&gt; None:\n    \"\"\"Export waldiez flow to python script.\n\n    Parameters\n    ----------\n    path : Path\n        The path to export to.\n\n    Raises\n    ------\n    RuntimeError\n        If the python script could not be generated.\n    \"\"\"\n    exporter = FlowExporter(\n        waldiez=self.waldiez,\n        output_dir=path.parent,\n        for_notebook=False,\n    )\n    output = exporter.export()\n    content = output[\"content\"]\n    if not content:\n        raise RuntimeError(\"Could not generate python script\")\n    with open(path, \"w\", encoding=\"utf-8\", newline=\"\\n\") as file:\n        file.write(content)\n</code></pre>"},{"location":"exporter/#waldiez.exporter.WaldiezExporter.to_waldiez","title":"<code>to_waldiez(file_path: Path) -&gt; None</code>","text":"<p>Export the Waldiez instance.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The file path.</p> required Source code in <code>waldiez/exporter.py</code> <pre><code>def to_waldiez(self, file_path: Path) -&gt; None:\n    \"\"\"Export the Waldiez instance.\n\n    Parameters\n    ----------\n    file_path : Path\n        The file path.\n    \"\"\"\n    with open(file_path, \"w\", encoding=\"utf-8\", newline=\"\\n\") as file:\n        file.write(self.waldiez.model_dump_json())\n</code></pre>"},{"location":"runner/","title":"WaldiezRunner","text":"<p>Run a waldiez flow. The flow is first converted to an autogen flow with agents, chats and skills. We then chown to temporary directory, call the flow's <code>main()</code> and return the results. Before running the flow, any additional environment variables specified in the waldiez file are set.</p>"},{"location":"runner/#waldiez.runner.WaldiezRunner","title":"<code>WaldiezRunner(waldiez: Waldiez, file_path: Optional[Union[str, Path]] = None)</code>","text":"<p>Waldiez runner class.</p> Source code in <code>waldiez/runner.py</code> <pre><code>def __init__(\n    self, waldiez: Waldiez, file_path: Optional[Union[str, Path]] = None\n) -&gt; None:\n    \"\"\"Initialize the Waldiez manager.\"\"\"\n    self._waldiez = waldiez\n    self._running = False\n    self._file_path = file_path\n    self._exporter = WaldiezExporter(waldiez)\n    self._called_install_requirements = False\n</code></pre>"},{"location":"runner/#waldiez.runner.WaldiezRunner.a_install_requirements","title":"<code>a_install_requirements() -&gt; None</code>  <code>async</code>","text":"<p>Install the requirements for the flow asynchronously.</p> Source code in <code>waldiez/runner.py</code> <pre><code>async def a_install_requirements(self) -&gt; None:\n    \"\"\"Install the requirements for the flow asynchronously.\"\"\"\n    self._called_install_requirements = True\n    printer = get_printer()\n    extra_requirements = self.gather_requirements()\n    if extra_requirements:\n        await a_install_requirements(extra_requirements, printer)\n        refresh_environment()\n</code></pre>"},{"location":"runner/#waldiez.runner.WaldiezRunner.a_run","title":"<code>a_run(output_path: Optional[Union[str, Path]] = None, uploads_root: Optional[Union[str, Path]] = None) -&gt; Union[ChatResult, List[ChatResult]]</code>  <code>async</code>","text":"<p>Run the Waldiez workflow asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>Optional[Union[str, Path]]</code> <p>The output path, by default None.</p> <code>None</code> <code>uploads_root</code> <code>Optional[Union[str, Path]]</code> <p>The uploads root, to get user-uploaded files, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[ChatResult, List[ChatResult]]</code> <p>The result(s) of the chat(s).</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the workflow is already running.</p> Source code in <code>waldiez/runner.py</code> <pre><code>async def a_run(\n    self,\n    output_path: Optional[Union[str, Path]] = None,\n    uploads_root: Optional[Union[str, Path]] = None,\n) -&gt; Union[\"ChatResult\", List[\"ChatResult\"]]:\n    \"\"\"Run the Waldiez workflow asynchronously.\n\n    Parameters\n    ----------\n    output_path : Optional[Union[str, Path]], optional\n        The output path, by default None.\n    uploads_root : Optional[Union[str, Path]], optional\n        The uploads root, to get user-uploaded files, by default None.\n\n    Returns\n    -------\n    Union[ChatResult, List[ChatResult]]\n        The result(s) of the chat(s).\n\n    Raises\n    ------\n    RuntimeError\n        If the workflow is already running.\n    \"\"\"\n    if self._running is True:\n        raise RuntimeError(\"Workflow already running\")\n    self._running = True\n    file_path = output_path or self._file_path\n    try:\n        return await self._a_run(file_path, uploads_root)\n    finally:\n        self._running = False\n</code></pre>"},{"location":"runner/#waldiez.runner.WaldiezRunner.gather_requirements","title":"<code>gather_requirements() -&gt; Set[str]</code>","text":"<p>Gather extra requirements to install before running the flow.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>The extra requirements.</p> Source code in <code>waldiez/runner.py</code> <pre><code>def gather_requirements(self) -&gt; Set[str]:\n    \"\"\"Gather extra requirements to install before running the flow.\n\n    Returns\n    -------\n    Set[str]\n        The extra requirements.\n    \"\"\"\n    extra_requirements = set(\n        req for req in self.waldiez.requirements if req not in sys.modules\n    )\n    if self.waldiez.has_captain_agents:\n        check_pysqlite3()\n    return extra_requirements\n</code></pre>"},{"location":"runner/#waldiez.runner.WaldiezRunner.install_requirements","title":"<code>install_requirements() -&gt; None</code>","text":"<p>Install the requirements for the flow.</p> Source code in <code>waldiez/runner.py</code> <pre><code>def install_requirements(self) -&gt; None:\n    \"\"\"Install the requirements for the flow.\"\"\"\n    self._called_install_requirements = True\n    printer = get_printer()\n    extra_requirements = self.gather_requirements()\n    if extra_requirements:\n        install_requirements(extra_requirements, printer)\n        refresh_environment()\n</code></pre>"},{"location":"runner/#waldiez.runner.WaldiezRunner.load","title":"<code>load(waldiez_file: Union[str, Path], name: Optional[str] = None, description: Optional[str] = None, tags: Optional[List[str]] = None, requirements: Optional[List[str]] = None) -&gt; WaldiezRunner</code>  <code>classmethod</code>","text":"<p>Create a WaldiezRunner instance from a file.</p> <p>Parameters:</p> Name Type Description Default <code>waldiez_file</code> <code>Union[str, Path]</code> <p>The file path.</p> required <code>name</code> <code>Optional[str]</code> <p>The name of the Waldiez, by default None.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>The description of the Waldiez, by default None.</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>The tags of the Waldiez, by default None.</p> <code>None</code> <code>requirements</code> <code>Optional[List[str]]</code> <p>The requirements of the Waldiez, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>WaldiezRunner</code> <p>The Waldiez runner instance.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file is not found.</p> <code>RuntimeError</code> <p>If the file is not a valid Waldiez file.</p> Source code in <code>waldiez/runner.py</code> <pre><code>@classmethod\ndef load(\n    cls,\n    waldiez_file: Union[str, Path],\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n    requirements: Optional[List[str]] = None,\n) -&gt; \"WaldiezRunner\":\n    \"\"\"Create a WaldiezRunner instance from a file.\n\n    Parameters\n    ----------\n    waldiez_file : Union[str, Path]\n        The file path.\n    name : Optional[str], optional\n        The name of the Waldiez, by default None.\n    description : Optional[str], optional\n        The description of the Waldiez, by default None.\n    tags : Optional[List[str]], optional\n        The tags of the Waldiez, by default None.\n    requirements : Optional[List[str]], optional\n        The requirements of the Waldiez, by default None.\n\n    Returns\n    -------\n    WaldiezRunner\n        The Waldiez runner instance.\n\n    Raises\n    ------\n    FileNotFoundError\n        If the file is not found.\n    RuntimeError\n        If the file is not a valid Waldiez file.\n    \"\"\"\n    waldiez = Waldiez.load(\n        waldiez_file,\n        name=name,\n        description=description,\n        tags=tags,\n        requirements=requirements,\n    )\n    return cls(waldiez, file_path=waldiez_file)\n</code></pre>"},{"location":"runner/#waldiez.runner.WaldiezRunner.run","title":"<code>run(output_path: Optional[Union[str, Path]] = None, uploads_root: Optional[Union[str, Path]] = None, skip_mmd: bool = False) -&gt; Union[ChatResult, List[ChatResult]]</code>","text":"<p>Run the Waldiez workflow.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>Optional[Union[str, Path]]</code> <p>The output path, by default None.</p> <code>None</code> <code>uploads_root</code> <code>Optional[Union[str, Path]]</code> <p>The uploads root, to get user-uploaded files, by default None.</p> <code>None</code> <code>skip_mmd</code> <code>bool</code> <p>Whether to skip the Mermaid diagram generation, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[ChatResult, List[ChatResult]]</code> <p>The result(s) of the chat(s).</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the workflow is already running.</p> Source code in <code>waldiez/runner.py</code> <pre><code>def run(\n    self,\n    output_path: Optional[Union[str, Path]] = None,\n    uploads_root: Optional[Union[str, Path]] = None,\n    skip_mmd: bool = False,\n) -&gt; Union[\"ChatResult\", List[\"ChatResult\"]]:\n    \"\"\"Run the Waldiez workflow.\n\n    Parameters\n    ----------\n    output_path : Optional[Union[str, Path]], optional\n        The output path, by default None.\n    uploads_root : Optional[Union[str, Path]], optional\n        The uploads root, to get user-uploaded files, by default None.\n    skip_mmd : bool, optional\n        Whether to skip the Mermaid diagram generation, by default False.\n\n    Returns\n    -------\n    Union[ChatResult, List[ChatResult]]\n        The result(s) of the chat(s).\n\n    Raises\n    ------\n    RuntimeError\n        If the workflow is already running.\n    \"\"\"\n    if self.waldiez.is_async:\n        # pylint: disable=import-outside-toplevel\n        from anyio.from_thread import start_blocking_portal\n\n        with start_blocking_portal(backend=\"asyncio\") as portal:\n            return portal.call(\n                self._a_run,\n                output_path,\n                uploads_root,\n                skip_mmd,\n            )\n    if self._running is True:\n        raise RuntimeError(\"Workflow already running\")\n    self._running = True\n    file_path = output_path or self._file_path\n    try:\n        return self._run(file_path, uploads_root, skip_mmd)\n    finally:\n        self._running = False\n</code></pre>"},{"location":"runner/#waldiez.runner.WaldiezRunner.running","title":"<code>running: bool</code>  <code>property</code>","text":"<p>Get the running status.</p>"},{"location":"runner/#waldiez.runner.WaldiezRunner.waldiez","title":"<code>waldiez: Waldiez</code>  <code>property</code>","text":"<p>Get the Waldiez instance.</p>"},{"location":"waldiez/","title":"Waldiez","text":"<p>Waldiez</p> <p>A Waldiez class contains all the information that is needed to generate and run an autogen workflow. It has the model/LLM configurations, the agent definitions and their optional additional skills to be used.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez","title":"<code>Waldiez(flow: WaldiezFlow)</code>  <code>dataclass</code>","text":"<p>Waldiez data class.</p> <p>It contains all the information to generate and run an autogen workflow.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.agents","title":"<code>agents: Iterator[WaldiezAgent]</code>  <code>property</code>","text":"<p>Get the agents.</p> <p>Yields:</p> Type Description <code>WaldiezAgent</code> <p>The flow agents.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.cache_seed","title":"<code>cache_seed: Optional[int]</code>  <code>property</code>","text":"<p>Get the cache seed.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.chats","title":"<code>chats: List[Tuple[WaldiezChat, WaldiezAgent, WaldiezAgent]]</code>  <code>property</code>","text":"<p>Get the chats.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Get the flow description.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.from_dict","title":"<code>from_dict(data: Dict[str, Any], flow_id: Optional[str] = None, name: Optional[str] = None, description: Optional[str] = None, tags: Optional[List[str]] = None, requirements: Optional[List[str]] = None) -&gt; Waldiez</code>  <code>classmethod</code>","text":"<p>Create a Waldiez from dict.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data.</p> required <code>flow_id</code> <code>Optional[str]</code> <p>The flow id, by default None (retrieved from data or generated).</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>The name, by default None (retrieved from data).</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>The description, by default None (retrieved from data).</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>The tags, by default None (retrieved from data).</p> <code>None</code> <code>requirements</code> <code>Optional[List[str]]</code> <p>The requirements, by default None (retrieved from data).</p> <code>None</code> <p>Returns:</p> Type Description <code>Waldiez</code> <p>The Waldiez.</p> Source code in <code>waldiez/models/waldiez.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls,\n    data: Dict[str, Any],\n    flow_id: Optional[str] = None,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n    requirements: Optional[List[str]] = None,\n) -&gt; \"Waldiez\":\n    \"\"\"Create a Waldiez from dict.\n\n    Parameters\n    ----------\n    data : Dict[str, Any]\n        The data.\n    flow_id : Optional[str], optional\n        The flow id, by default None (retrieved from data or generated).\n    name : Optional[str], optional\n        The name, by default None (retrieved from data).\n    description : Optional[str], optional\n        The description, by default None (retrieved from data).\n    tags : Optional[List[str]], optional\n        The tags, by default None (retrieved from data).\n    requirements : Optional[List[str]], optional\n        The requirements, by default None (retrieved from data).\n\n    Returns\n    -------\n    Waldiez\n        The Waldiez.\n    \"\"\"\n    flow = get_flow_data(\n        data,\n        flow_id=flow_id,\n        name=name,\n        description=description,\n        tags=tags,\n        requirements=requirements,\n    )\n    return cls(flow=WaldiezFlow.model_validate(flow))\n</code></pre>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.get_flow_env_vars","title":"<code>get_flow_env_vars() -&gt; List[Tuple[str, str]]</code>","text":"<p>Get the flow environment variables.</p> <p>Returns:</p> Type Description <code>List[Tuple[str, str]]</code> <p>The environment variables for the flow.</p> Source code in <code>waldiez/models/waldiez.py</code> <pre><code>def get_flow_env_vars(self) -&gt; List[Tuple[str, str]]:\n    \"\"\"Get the flow environment variables.\n\n    Returns\n    -------\n    List[Tuple[str, str]]\n        The environment variables for the flow.\n    \"\"\"\n    env_vars: List[Tuple[str, str]] = []\n    for skill in self.skills:\n        for secret_key, secret_value in skill.secrets.items():\n            env_vars.append((secret_key, secret_value))\n    return env_vars\n</code></pre>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.get_group_chat_members","title":"<code>get_group_chat_members(agent: WaldiezAgent) -&gt; List[WaldiezAgent]</code>","text":"<p>Get the chat members that connect to a group chat manager agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>WaldiezAgent</code> <p>The agent (group chat manager).</p> required <p>Returns:</p> Type Description <code>List[WaldiezAgent]</code> <p>The group chat members.</p> Source code in <code>waldiez/models/waldiez.py</code> <pre><code>def get_group_chat_members(self, agent: WaldiezAgent) -&gt; List[WaldiezAgent]:\n    \"\"\"Get the chat members that connect to a group chat manager agent.\n\n    Parameters\n    ----------\n    agent : WaldiezAgent\n        The agent (group chat manager).\n\n    Returns\n    -------\n    List[WaldiezAgent]\n        The group chat members.\n    \"\"\"\n    if agent.agent_type != \"manager\":\n        return []\n    return self.flow.get_group_chat_members(agent.id)\n</code></pre>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.get_swarm_members","title":"<code>get_swarm_members(initial_agent: WaldiezAgent) -&gt; Tuple[List[WaldiezAgent], Optional[WaldiezAgent]]</code>","text":"<p>Get the chat members that connect to a swarm agent.</p> <p>Parameters:</p> Name Type Description Default <code>initial_agent</code> <code>WaldiezAgent</code> <p>The initial agent.</p> required <p>Returns:</p> Type Description <code>Tuple[List[WaldiezAgent], Optional[WaldiezAgent]]</code> <p>The swarm agents and the user agent.</p> Source code in <code>waldiez/models/waldiez.py</code> <pre><code>def get_swarm_members(\n    self, initial_agent: WaldiezAgent\n) -&gt; Tuple[List[WaldiezAgent], Optional[WaldiezAgent]]:\n    \"\"\"Get the chat members that connect to a swarm agent.\n\n    Parameters\n    ----------\n    initial_agent : WaldiezAgent\n        The initial agent.\n\n    Returns\n    -------\n    Tuple[List[WaldiezAgent], Optional[WaldiezAgent]]\n        The swarm agents and the user agent.\n    \"\"\"\n    return self.flow.get_swarm_chat_members(initial_agent)\n</code></pre>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.has_captain_agents","title":"<code>has_captain_agents: bool</code>  <code>property</code>","text":"<p>Check if the flow has captain agents.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.has_multimodal_agents","title":"<code>has_multimodal_agents: bool</code>  <code>property</code>","text":"<p>Check if the flow has multimodal agents.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.has_rag_agents","title":"<code>has_rag_agents: bool</code>  <code>property</code>","text":"<p>Check if the flow has RAG agents.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.is_async","title":"<code>is_async: bool</code>  <code>property</code>","text":"<p>Check if the flow is asynchronous.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.is_single_agent_mode","title":"<code>is_single_agent_mode: bool</code>  <code>property</code>","text":"<p>Check if the flow is single agent mode.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.load","title":"<code>load(waldiez_file: Union[str, Path], name: Optional[str] = None, description: Optional[str] = None, tags: Optional[List[str]] = None, requirements: Optional[List[str]] = None) -&gt; Waldiez</code>  <code>classmethod</code>","text":"<p>Load a Waldiez from a file.</p> <p>Parameters:</p> Name Type Description Default <code>waldiez_file</code> <code>Union[str, Path]</code> <p>The Waldiez file.</p> required <code>name</code> <code>Optional[str]</code> <p>The name, by default None.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>The description, by default None.</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>The tags, by default None.</p> <code>None</code> <code>requirements</code> <code>Optional[List[str]]</code> <p>The requirements, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Waldiez</code> <p>The Waldiez.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file is not found or invalid JSON.</p> Source code in <code>waldiez/models/waldiez.py</code> <pre><code>@classmethod\ndef load(\n    cls,\n    waldiez_file: Union[str, Path],\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n    requirements: Optional[List[str]] = None,\n) -&gt; \"Waldiez\":\n    \"\"\"Load a Waldiez from a file.\n\n    Parameters\n    ----------\n    waldiez_file : Union[str, Path]\n        The Waldiez file.\n    name : Optional[str], optional\n        The name, by default None.\n    description : Optional[str], optional\n        The description, by default None.\n    tags : Optional[List[str]], optional\n        The tags, by default None.\n    requirements : Optional[List[str]], optional\n        The requirements, by default None.\n\n    Returns\n    -------\n    Waldiez\n        The Waldiez.\n\n    Raises\n    ------\n    ValueError\n        If the file is not found or invalid JSON.\n    \"\"\"\n    data: Dict[str, Any] = {}\n    if not Path(waldiez_file).exists():\n        raise ValueError(f\"File not found: {waldiez_file}\")\n    with open(waldiez_file, \"r\", encoding=\"utf-8\") as file:\n        try:\n            data = json.load(file)\n        except json.decoder.JSONDecodeError as error:\n            raise ValueError(f\"Invalid JSON: {waldiez_file}\") from error\n    return cls.from_dict(\n        data,\n        name=name,\n        description=description,\n        tags=tags,\n        requirements=requirements,\n    )\n</code></pre>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.model_dump_json","title":"<code>model_dump_json(by_alias: bool = True, indent: Optional[int] = None) -&gt; str</code>","text":"<p>Get the model dump json.</p> <p>We use <code>by_alias=True</code> by default to use the alias (toCamel).</p> <p>Parameters:</p> Name Type Description Default <code>by_alias</code> <code>bool</code> <p>Use alias (toCamel), by default True.</p> <code>True</code> <code>indent</code> <code>Optional[int]</code> <p>The indent, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The model dump json.</p> Source code in <code>waldiez/models/waldiez.py</code> <pre><code>def model_dump_json(\n    self, by_alias: bool = True, indent: Optional[int] = None\n) -&gt; str:\n    \"\"\"Get the model dump json.\n\n    We use `by_alias=True` by default to use the alias (toCamel).\n\n    Parameters\n    ----------\n    by_alias : bool, optional\n        Use alias (toCamel), by default True.\n    indent : Optional[int], optional\n        The indent, by default None.\n\n    Returns\n    -------\n    str\n        The model dump json.\n    \"\"\"\n    return self.flow.model_dump_json(by_alias=by_alias, indent=indent)\n</code></pre>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.models","title":"<code>models: Iterator[WaldiezModel]</code>  <code>property</code>","text":"<p>Get the models.</p> <p>Yields:</p> Type Description <code>WaldiezModel</code> <p>The flow models.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get the flow name.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.requirements","title":"<code>requirements: List[str]</code>  <code>property</code>","text":"<p>Get the flow requirements.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.skills","title":"<code>skills: Iterator[WaldiezSkill]</code>  <code>property</code>","text":"<p>Get the flow skills.</p> <p>Yields:</p> Type Description <code>WaldiezSkill</code> <p>The skills.</p>"},{"location":"waldiez/#waldiez.models.waldiez.Waldiez.tags","title":"<code>tags: List[str]</code>  <code>property</code>","text":"<p>Get the flow tags.</p>"},{"location":"exporting/agents/","title":"Agents","text":"<p>Export agents.</p>"},{"location":"exporting/agents/#waldiez.exporting.agent.agent_exporter.AgentExporter","title":"<code>AgentExporter(agent: WaldiezAgent, agent_names: Dict[str, str], models: Tuple[List[WaldiezModel], Dict[str, str]], chats: Tuple[List[WaldiezChat], Dict[str, str]], skill_names: Dict[str, str], is_async: bool, group_chat_members: List[WaldiezAgent], for_notebook: bool, arguments_resolver: Callable[[WaldiezAgent], List[str]], output_dir: Optional[Union[str, Path]] = None)</code>","text":"<p>               Bases: <code>BaseExporter</code>, <code>ExporterMixin</code></p> <p>Agents exporter.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>WaldiezAgent</code> <p>The agent to export.</p> required <code>agent_names</code> <code>Dict[str, str]</code> <p>The agent ids to names mapping.</p> required <code>models</code> <code>Tuple[List[WaldiezModel], Dict[str, str]]</code> <p>All the models and the model ids to names mapping.</p> required <code>chats</code> <code>Tuple[List[WaldiezChat], Dict[str, str]]</code> <p>All the chats and the chat ids to names mapping.</p> required <code>skill_names</code> <code>Dict[str, str]</code> <p>The skill ids to names mapping.</p> required <code>is_async</code> <code>bool</code> <p>Whether the whole flow is async.</p> required <code>for_notebook</code> <code>bool</code> <p>Whether the exporter is for a notebook.</p> required <code>output_dir</code> <code>Optional[Union[str, Path]]</code> <p>The output directory, by default None</p> <code>None</code> Source code in <code>waldiez/exporting/agent/agent_exporter.py</code> <pre><code>def __init__(\n    self,\n    agent: WaldiezAgent,\n    agent_names: Dict[str, str],\n    models: Tuple[List[WaldiezModel], Dict[str, str]],\n    chats: Tuple[List[WaldiezChat], Dict[str, str]],\n    skill_names: Dict[str, str],\n    is_async: bool,\n    group_chat_members: List[WaldiezAgent],\n    for_notebook: bool,\n    arguments_resolver: Callable[[WaldiezAgent], List[str]],\n    output_dir: Optional[Union[str, Path]] = None,\n) -&gt; None:\n    \"\"\"Initialize the agents exporter.\n\n    Parameters\n    ----------\n    agent : WaldiezAgent\n        The agent to export.\n    agent_names : Dict[str, str]\n        The agent ids to names mapping.\n    models : Tuple[List[WaldiezModel], Dict[str, str]]\n        All the models and the model ids to names mapping.\n    chats : Tuple[List[WaldiezChat], Dict[str, str]]\n        All the chats and the chat ids to names mapping.\n    skill_names : Dict[str, str]\n        The skill ids to names mapping.\n    is_async : bool\n        Whether the whole flow is async.\n    for_notebook : bool\n        Whether the exporter is for a notebook.\n    output_dir : Optional[Union[str, Path]], optional\n        The output directory, by default None\n    \"\"\"\n    self.for_notebook = for_notebook\n    self.agent = agent\n    self.agent_names = agent_names\n    if output_dir is not None and not isinstance(output_dir, Path):\n        output_dir = Path(output_dir)\n    self.output_dir = output_dir\n    self.models = models[0]\n    self.model_names = models[1]\n    self.skill_names = skill_names\n    self.arguments_resolver = arguments_resolver\n    self.group_chat_members = group_chat_members\n    self.chats = chats\n    self.is_async = is_async\n    self._agent_name = agent_names[agent.id]\n    # content, argument, import\n    self._code_execution = get_agent_code_execution_config(\n        agent=self.agent,\n        agent_name=self._agent_name,\n        skill_names=self.skill_names,\n    )\n    # before_rag, retrieve_arg, rag_imports\n    self._rag = get_rag_user_extras(\n        agent=self.agent,\n        agent_name=self._agent_name,\n        model_names=self.model_names,\n        path_resolver=self.path_resolver,\n        serializer=self.serializer,\n    )\n    # before_manager, group_chat_arg\n    self._group_chat = get_group_manager_extras(\n        agent=self.agent,\n        agent_names=self.agent_names,\n        group_chat_members=self.group_chat_members,\n        serializer=self.serializer,\n    )\n    # before_agent, extra args, handoff_registrations\n    self._swarm = get_swarm_extras(\n        agent=self.agent,\n        agent_names=self.agent_names,\n        skill_names=self.skill_names,\n        chats=self.chats,\n        is_async=self.is_async,\n        serializer=self.serializer,\n        string_escape=self.string_escape,\n    )\n    # before_agent, termination_arg\n    self._termination = get_is_termination_message(\n        agent=self.agent, agent_name=self._agent_name\n    )\n    self._reasoning = get_reasoning_agent_extras(\n        agent=self.agent,\n        serializer=self.serializer,\n    )\n    self._captain = get_captain_agent_extras(\n        agent=self.agent,\n        agent_names=self.agent_names,\n        all_models=self.models,\n        serializer=self.serializer,\n        output_dir=self.output_dir,\n    )\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agent.agent_exporter.AgentExporter.export","title":"<code>export() -&gt; ExporterReturnType</code>","text":"<p>Export the agent.</p> <p>Returns:</p> Type Description <code>ExporterReturnType</code> <p>The exported agent.</p> Source code in <code>waldiez/exporting/agent/agent_exporter.py</code> <pre><code>def export(self) -&gt; ExporterReturnType:\n    \"\"\"Export the agent.\n\n    Returns\n    -------\n    ExporterReturnType\n        The exported agent.\n    \"\"\"\n    agent_string = self.generate() or \"\"\n    is_group_manager = self.agent.agent_type == \"group_manager\"\n    after_export = self.get_after_export() or []\n    content: Optional[str] = agent_string\n    if is_group_manager and agent_string:\n        content = None\n        # make sure the group manager is defined\n        # after the rest of the agents.\n        # to avoid issues with (for example):\n        #  'group_manager_group_chat = GroupChat(\n        #    # assistant and rag_user should be defined first\n        # '    agents=[assistant, rag_user],\n        # '    enable_clear_history=True,\n        # ...\n        after_export.append(\n            (agent_string, AgentPosition(None, AgentPositions.AFTER_ALL, 0))\n        )\n    return {\n        \"content\": content,\n        \"imports\": self.get_imports(),\n        \"environment_variables\": [],\n        \"before_export\": self.get_before_export(),\n        \"after_export\": after_export,\n    }\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agent.agent_exporter.AgentExporter.generate","title":"<code>generate() -&gt; Optional[str]</code>","text":"<p>Generate the exported agent.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The exported agent.</p> Source code in <code>waldiez/exporting/agent/agent_exporter.py</code> <pre><code>    def generate(self) -&gt; Optional[str]:\n        \"\"\"Generate the exported agent.\n\n        Returns\n        -------\n        Optional[str]\n            The exported agent.\n        \"\"\"\n        agent = self.agent\n        agent_name = self._agent_name\n        retrieve_arg = self._rag[1]\n        group_chat_arg = self._group_chat[1]\n        is_termination = self._termination[0]\n        code_execution_arg = self._code_execution[1]\n        system_message_arg = self.get_system_message_arg()\n        default_auto_reply: str = \"None\"\n        if agent.data.agent_default_auto_reply:\n            default_auto_reply = (\n                f'\"{self.string_escape(agent.data.agent_default_auto_reply)}\"'\n            )\n        extras = (\n            f\"{group_chat_arg}{retrieve_arg}{self._reasoning}{self._captain}\"\n        )\n        agent_str = f\"\"\"{agent_name} = {self.agent.ag2_class}(\n    name=\"{agent_name}\",\n    description=\"{agent.description}\"{system_message_arg},\n    human_input_mode=\"{agent.data.human_input_mode}\",\n    max_consecutive_auto_reply={agent.data.max_consecutive_auto_reply},\n    default_auto_reply={default_auto_reply},\n    code_execution_config={code_execution_arg},\n    is_termination_msg={is_termination},{extras}\n\"\"\"\n        if self._swarm[1]:\n            agent_str += self._swarm[1]\n        # e.g. llm_config=...\n        other_args = self.arguments_resolver(agent)\n        if other_args:\n            agent_str += \",\\n\".join(other_args)\n        if not agent_str.endswith(\"\\n\"):\n            agent_str += \"\\n\"\n        agent_str += \")\"\n        return agent_str\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agent.agent_exporter.AgentExporter.get_after_export","title":"<code>get_after_export() -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code>","text":"<p>Generate the content after the main export.</p> <p>Returns:</p> Type Description <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The exported content after the main export and its position.</p> Source code in <code>waldiez/exporting/agent/agent_exporter.py</code> <pre><code>def get_after_export(\n    self,\n) -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]:\n    \"\"\"Generate the content after the main export.\n\n    Returns\n    -------\n    Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]\n        The exported content after the main export and its position.\n    \"\"\"\n    after_agent_string = \"\"\n    if self._swarm[2]:\n        after_agent_string += self._swarm[2]\n    if after_agent_string:\n        return [\n            (\n                after_agent_string,\n                AgentPosition(self.agent, AgentPositions.AFTER_ALL),\n            )\n        ]\n    return None\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agent.agent_exporter.AgentExporter.get_before_export","title":"<code>get_before_export() -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code>","text":"<p>Generate the content before the main export.</p> <p>Returns:</p> Type Description <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The exported content before the main export and its position.</p> Source code in <code>waldiez/exporting/agent/agent_exporter.py</code> <pre><code>def get_before_export(\n    self,\n) -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]:\n    \"\"\"Generate the content before the main export.\n\n    Returns\n    -------\n    Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]\n        The exported content before the main export and its position.\n    \"\"\"\n    before_agent_string = \"\"\n    if self._code_execution[0] and self._code_execution[2]:\n        before_agent_string += self._code_execution[0]\n    if self._termination[1]:\n        before_agent_string += self._termination[1]\n    if self._group_chat[0]:\n        before_agent_string += self._group_chat[0]\n    if self._rag[0]:\n        before_agent_string += self._rag[0]\n    if self._swarm[0]:\n        before_agent_string += self._swarm[0]\n    if before_agent_string:\n        return [\n            (\n                before_agent_string,\n                AgentPosition(self.agent, AgentPositions.BEFORE),\n            )\n        ]\n    return None\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agent.agent_exporter.AgentExporter.get_imports","title":"<code>get_imports() -&gt; Optional[List[Tuple[str, ImportPosition]]]</code>","text":"<p>Get the imports.</p> <p>Returns:</p> Type Description <code>Optional[Tuple[str, ImportPosition]]</code> <p>The imports.</p> Source code in <code>waldiez/exporting/agent/agent_exporter.py</code> <pre><code>def get_imports(self) -&gt; Optional[List[Tuple[str, ImportPosition]]]:\n    \"\"\"Get the imports.\n\n    Returns\n    -------\n    Optional[Tuple[str, ImportPosition]]\n        The imports.\n    \"\"\"\n    position = ImportPosition.THIRD_PARTY\n    # default imports based on the agent class.\n    agent_imports = self.agent.ag2_imports\n    # if code execution is enabled, update the imports.\n    if self._code_execution[2]:\n        agent_imports.add(self._code_execution[2])\n    # if RAG is enabled, update the imports.\n    if self._rag[2]:\n        agent_imports.update(self._rag[2])\n    # if the agent has skills, add the register_function import.\n    if self.agent.data.skills:\n        agent_imports.add(\"from autogen import register_function\")\n    return sorted(\n        [(import_string, position) for import_string in agent_imports],\n        key=lambda x: x[0],\n    )\n</code></pre>"},{"location":"exporting/agents/#waldiez.exporting.agent.agent_exporter.AgentExporter.get_system_message_arg","title":"<code>get_system_message_arg() -&gt; str</code>","text":"<p>Get the system message argument.</p> <p>Returns:</p> Type Description <code>str</code> <p>The system message argument.</p> Source code in <code>waldiez/exporting/agent/agent_exporter.py</code> <pre><code>def get_system_message_arg(self) -&gt; str:\n    \"\"\"Get the system message argument.\n\n    Returns\n    -------\n    str\n        The system message argument.\n    \"\"\"\n    if not self.agent.data.system_message:\n        return \"\"\n    system_message = self.string_escape(self.agent.data.system_message)\n    return \",\\n    system_message=\" + f'\"{system_message}\"'\n</code></pre>"},{"location":"exporting/base/","title":"Base","text":"<p>Base classes, mixins, and utilities for exporting data.</p> <p>Each exporter should inherit from the <code>BaseExporter</code> class and implement the <code>export</code> method. The <code>export</code> method should return the exported content as an instance of the <code>ExporterReturnType</code> typed dictionary.</p> <p>               Bases: <code>TypedDict</code></p> <p>Exporter Return Type.</p> <p>Attributes:</p> Name Type Description <code>content</code> <code>Optional[str]</code> <p>The exported content.</p> <code>imports</code> <code>Optional[List[Tuple[str, ImportPosition]]]</code> <p>The additional imports required for the exported content.</p> <code>environment_variables</code> <code>Optional[List[Tuple[str, str]]]</code> <p>The environment variables to set.</p> <code>before_export</code> <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The exported content before the main export and its position.</p> <code>after_export</code> <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The exported content after the main export and its position.</p> <p>               Bases: <code>ABC</code></p> <p>Base exporter.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>The positional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments.</p> <code>{}</code> Source code in <code>waldiez/exporting/base/base_exporter.py</code> <pre><code>@abc.abstractmethod\ndef __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize the exporter.\n\n    Parameters\n    ----------\n    *args : Any\n        The positional arguments.\n    **kwargs : Any\n        The keyword arguments.\n    \"\"\"\n    raise NotImplementedError(\"Method not implemented.\")\n</code></pre> <p>Export position enum.</p> <p>Import position enum.</p> <p>Agent position generation.</p> <p>The base exporter mixin.</p> <p>Generic utils to be used for exporting.</p>"},{"location":"exporting/base/#waldiez.exporting.base.base_exporter.BaseExporter.export","title":"<code>export() -&gt; ExporterReturnType</code>  <code>abstractmethod</code>","text":"<p>Export the content.</p> <p>Returns:</p> Type Description <code>ExporterReturnType</code> <p>The exported content.</p> Source code in <code>waldiez/exporting/base/base_exporter.py</code> <pre><code>@abc.abstractmethod\ndef export(self) -&gt; ExporterReturnType:\n    \"\"\"Export the content.\n\n    Returns\n    -------\n    ExporterReturnType\n        The exported content.\n    \"\"\"\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.base_exporter.BaseExporter.generate","title":"<code>generate() -&gt; Optional[str]</code>","text":"<p>Generate the main export.</p> <p>Returns:</p> Type Description <code>str</code> <p>The exported content.</p> Source code in <code>waldiez/exporting/base/base_exporter.py</code> <pre><code>def generate(\n    self,\n) -&gt; Optional[str]:\n    \"\"\"Generate the main export.\n\n    Returns\n    -------\n    str\n        The exported content.\n    \"\"\"\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.base_exporter.BaseExporter.get_after_export","title":"<code>get_after_export() -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code>","text":"<p>Generate the content after the main export.</p> <p>Returns:</p> Type Description <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The exported content after the main export and its position.</p> Source code in <code>waldiez/exporting/base/base_exporter.py</code> <pre><code>def get_after_export(\n    self,\n) -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]:\n    \"\"\"Generate the content after the main export.\n\n    Returns\n    -------\n    Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]\n        The exported content after the main export and its position.\n    \"\"\"\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.base_exporter.BaseExporter.get_before_export","title":"<code>get_before_export() -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code>","text":"<p>Generate the content before the main export.</p> <p>Returns:</p> Type Description <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The exported content before the main export and its position.</p> Source code in <code>waldiez/exporting/base/base_exporter.py</code> <pre><code>def get_before_export(\n    self,\n) -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]:\n    \"\"\"Generate the content before the main export.\n\n    Returns\n    -------\n    Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]\n        The exported content before the main export and its position.\n    \"\"\"\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.base_exporter.BaseExporter.get_environment_variables","title":"<code>get_environment_variables() -&gt; Optional[List[Tuple[str, str]]]</code>","text":"<p>Get the environment variables to set.</p> <p>Returns:</p> Type Description <code>Optional[Set[Tuple[str, str]]]</code> <p>The environment variables to set if any.</p> Source code in <code>waldiez/exporting/base/base_exporter.py</code> <pre><code>def get_environment_variables(self) -&gt; Optional[List[Tuple[str, str]]]:\n    \"\"\"Get the environment variables to set.\n\n    Returns\n    -------\n    Optional[Set[Tuple[str, str]]]\n        The environment variables to set if any.\n    \"\"\"\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.base_exporter.BaseExporter.get_imports","title":"<code>get_imports() -&gt; Optional[List[Tuple[str, ImportPosition]]]</code>","text":"<p>\"Generate the imports string for the exporter.</p> <p>Returns:</p> Type Description <code>Optional[Tuple[str, ImportPosition]]</code> <p>The exported imports and the position of the imports.</p> Source code in <code>waldiez/exporting/base/base_exporter.py</code> <pre><code>def get_imports(self) -&gt; Optional[List[Tuple[str, ImportPosition]]]:\n    \"\"\" \"Generate the imports string for the exporter.\n\n    Returns\n    -------\n    Optional[Tuple[str, ImportPosition]]\n        The exported imports and the position of the imports.\n    \"\"\"\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.export_position.ExportPosition","title":"<code>ExportPosition(position: ExportPositions, order: int = 0)</code>  <code>dataclass</code>","text":"<p>Export position.</p> <p>Optionally, the order can be provided to sort the exported content.</p>"},{"location":"exporting/base/#waldiez.exporting.base.export_position.ExportPositions","title":"<code>ExportPositions</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Export position.</p> <p>Attributes:</p> Name Type Description <code>TOP</code> <code>int</code> <p>The top of the export (name, comments etc.)</p> <code>IMPORTS</code> <code>int</code> <p>The imports section.</p> <code>MODELS</code> <code>int</code> <p>The models section (define the llm_configs).</p> <code>SKILLS</code> <code>int</code> <p>The skills section (generate the skill files, and import them)</p> <code>AGENTS</code> <code>int</code> <p>The agents section.</p> <code>CHATS</code> <code>int</code> <p>The chats section (e.g. agent.initiate_chat, or initiate_chats)</p> <code>BOTTOM</code> <code>int</code> <p>The bottom part of the export (like the main function and calling it).</p>"},{"location":"exporting/base/#waldiez.exporting.base.import_position.ImportPosition","title":"<code>ImportPosition</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Import position.</p> <p>Attributes:</p> Name Type Description <code>BUILTINS</code> <code>int</code> <p>The top of the import (builtins)</p> <code>THIRD_PARTY</code> <code>int</code> <p>The third party imports.</p> <code>LOCAL</code> <code>int</code> <p>The local imports.</p>"},{"location":"exporting/base/#waldiez.exporting.base.agent_position.AgentPosition","title":"<code>AgentPosition(agent: Optional[WaldiezAgent], position: AgentPositions, order: int = 0)</code>  <code>dataclass</code>","text":"<p>Agent position.</p> <p>Attributes:</p> Name Type Description <code>agent</code> <code>Optional[WaldiezAgent]</code> <p>The agent.</p> <code>position</code> <code>AgentPositions</code> <p>The position.</p> <code>order</code> <code>int</code> <p>The order of the agent position.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the position is not \"BEFORE_ALL\" or \"AFTER_ALL\" and the agent is not provided.</p>"},{"location":"exporting/base/#waldiez.exporting.base.agent_position.AgentPositions","title":"<code>AgentPositions</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Agent positions.</p> <p>Attributes:</p> Name Type Description <code>BEFORE_ALL</code> <code>int</code> <p>Before all agents.</p> <code>BEFORE</code> <code>int</code> <p>Before the agent.</p> <code>AS_ARGUMENT</code> <code>int</code> <p>As an argument of the agent's initialization.</p> <code>AFTER</code> <code>int</code> <p>After the agent.</p> <code>AFTER_ALL</code> <code>int</code> <p>After all agents.</p>"},{"location":"exporting/base/#waldiez.exporting.base.mixin.ExporterMixin","title":"<code>ExporterMixin</code>","text":"<p>Static methods to be used by the exporters.</p>"},{"location":"exporting/base/#waldiez.exporting.base.mixin.ExporterMixin.comment","title":"<code>comment(for_notebook: bool, hashtags: int = 1) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Comment the text.</p> <p>Parameters:</p> Name Type Description Default <code>for_notebook</code> <code>bool</code> <p>Whether the comment is for a notebook or not.</p> required <code>hashtags</code> <code>int</code> <p>The number of hashtags (for notebooks), by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The commented text.</p> Source code in <code>waldiez/exporting/base/mixin.py</code> <pre><code>@staticmethod\ndef comment(for_notebook: bool, hashtags: int = 1) -&gt; str:\n    \"\"\"Comment the text.\n\n    Parameters\n    ----------\n    for_notebook : bool\n        Whether the comment is for a notebook or not.\n    hashtags : int, optional\n        The number of hashtags (for notebooks), by default 1.\n\n    Returns\n    -------\n    str\n        The commented text.\n    \"\"\"\n    return comment(for_notebook=for_notebook, hashtags=hashtags)\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.mixin.ExporterMixin.get_comment","title":"<code>get_comment(key: CommentKey, for_notebook: bool) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Get the comment string.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>CommentKey</code> <p>The comment key.</p> required <code>for_notebook</code> <code>bool</code> <p>Whether the comment is for a notebook or not.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The comment string.</p> Source code in <code>waldiez/exporting/base/mixin.py</code> <pre><code>@staticmethod\ndef get_comment(key: CommentKey, for_notebook: bool) -&gt; str:\n    \"\"\"Get the comment string.\n\n    Parameters\n    ----------\n    key : CommentKey\n        The comment key.\n    for_notebook : bool\n        Whether the comment is for a notebook or not.\n    Returns\n    -------\n    str\n        The comment string.\n    \"\"\"\n    return get_comment(key=key, for_notebook=for_notebook)\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.mixin.ExporterMixin.get_valid_instance_name","title":"<code>get_valid_instance_name(instance: Tuple[str, str], current_names: Dict[str, str], prefix: str = 'w', max_length: int = 64) -&gt; Dict[str, str]</code>  <code>staticmethod</code>","text":"<p>Get a valid instance name.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Tuple[str, str]</code> <p>The instance id and possible name.</p> required <code>current_names</code> <code>Dict[str, str]</code> <p>The current names.</p> required <code>prefix</code> <code>str</code> <p>The prefix for the instance name, by default \"w\".</p> <code>'w'</code> <code>max_length</code> <code>int</code> <p>The maximum length of the variable name, by default 64</p> <code>64</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>The updated dictionary of current names.</p> Source code in <code>waldiez/exporting/base/mixin.py</code> <pre><code>@staticmethod\ndef get_valid_instance_name(\n    instance: Tuple[str, str],\n    current_names: Dict[str, str],\n    prefix: str = \"w\",\n    max_length: int = 64,\n) -&gt; Dict[str, str]:\n    \"\"\"Get a valid instance name.\n\n    Parameters\n    ----------\n    instance : Tuple[str, str]\n        The instance id and possible name.\n    current_names : Dict[str, str]\n        The current names.\n    prefix : str, optional\n        The prefix for the instance name, by default \"w\".\n    max_length : int, optional\n        The maximum length of the variable name, by default 64\n    Returns\n    -------\n    Dict[str, str]\n        The updated dictionary of current names.\n    \"\"\"\n    return get_valid_instance_name(\n        instance=instance,\n        current_names=current_names,\n        prefix=prefix,\n        max_length=max_length,\n    )\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.mixin.ExporterMixin.path_resolver","title":"<code>path_resolver(path: str) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Get the path string.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The path string.</p> Source code in <code>waldiez/exporting/base/mixin.py</code> <pre><code>@staticmethod\ndef path_resolver(path: str) -&gt; str:\n    \"\"\"Get the path string.\n\n    Parameters\n    ----------\n    path : str\n        The path.\n\n    Returns\n    -------\n    str\n        The path string.\n    \"\"\"\n    return get_path_string(path)\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.mixin.ExporterMixin.serializer","title":"<code>serializer(item: Any, tabs: int = 1) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Get the string representation of an item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item.</p> required <code>tabs</code> <code>int</code> <p>The number of tabs for indentation, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the item.</p> Source code in <code>waldiez/exporting/base/mixin.py</code> <pre><code>@staticmethod\ndef serializer(item: Any, tabs: int = 1) -&gt; str:\n    \"\"\"Get the string representation of an item.\n\n    Parameters\n    ----------\n    item : Any\n        The item.\n    tabs : int, optional\n        The number of tabs for indentation, by default 1.\n    Returns\n    -------\n    str\n        The string representation of the item.\n    \"\"\"\n    return get_item_string(item=item, tabs=tabs)\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.mixin.ExporterMixin.string_escape","title":"<code>string_escape(string: str) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Get a string with escaped quotes and newlines.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The escaped string.</p> Source code in <code>waldiez/exporting/base/mixin.py</code> <pre><code>@staticmethod\ndef string_escape(string: str) -&gt; str:\n    \"\"\"Get a string with escaped quotes and newlines.\n\n    Parameters\n    ----------\n    string : str\n        The original string.\n\n    Returns\n    -------\n    str\n        The escaped string.\n    \"\"\"\n    return get_escaped_string(string)\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.comment","title":"<code>comment(for_notebook: bool, hashtags: int = 1) -&gt; str</code>","text":"<p>Get the comment string.</p> <p>Parameters:</p> Name Type Description Default <code>for_notebook</code> <code>bool</code> <p>Whether the comment is for a notebook or not.</p> required <code>hashtags</code> <code>int</code> <p>The number of hashtags (for notebooks), by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The comment string.</p> Example <pre><code>&gt;&gt;&gt; comment(True, 2)\n'## '\n&gt;&gt;&gt; comment(False)\n'# '\n</code></pre> Source code in <code>waldiez/exporting/base/utils/comments.py</code> <pre><code>def comment(for_notebook: bool, hashtags: int = 1) -&gt; str:\n    \"\"\"Get the comment string.\n\n    Parameters\n    ----------\n    for_notebook : bool\n        Whether the comment is for a notebook or not.\n    hashtags : int, optional\n        The number of hashtags (for notebooks), by default 1.\n\n    Returns\n    -------\n    str\n        The comment string.\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; comment(True, 2)\n    '## '\n    &gt;&gt;&gt; comment(False)\n    '# '\n    ```\n    \"\"\"\n    content = \"# \"\n    if for_notebook:\n        content += \"#\" * hashtags + \" \"\n    return content\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.comments","title":"<code>comments</code>","text":"Utilities for comments. <p>comment     Get a comment string. get_comment     Get a comment string for some common keys (notebook headings).</p>"},{"location":"exporting/base/#waldiez.exporting.base.utils.comments.comment","title":"<code>comment(for_notebook: bool, hashtags: int = 1) -&gt; str</code>","text":"<p>Get the comment string.</p> <p>Parameters:</p> Name Type Description Default <code>for_notebook</code> <code>bool</code> <p>Whether the comment is for a notebook or not.</p> required <code>hashtags</code> <code>int</code> <p>The number of hashtags (for notebooks), by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The comment string.</p> Example <pre><code>&gt;&gt;&gt; comment(True, 2)\n'## '\n&gt;&gt;&gt; comment(False)\n'# '\n</code></pre> Source code in <code>waldiez/exporting/base/utils/comments.py</code> <pre><code>def comment(for_notebook: bool, hashtags: int = 1) -&gt; str:\n    \"\"\"Get the comment string.\n\n    Parameters\n    ----------\n    for_notebook : bool\n        Whether the comment is for a notebook or not.\n    hashtags : int, optional\n        The number of hashtags (for notebooks), by default 1.\n\n    Returns\n    -------\n    str\n        The comment string.\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; comment(True, 2)\n    '## '\n    &gt;&gt;&gt; comment(False)\n    '# '\n    ```\n    \"\"\"\n    content = \"# \"\n    if for_notebook:\n        content += \"#\" * hashtags + \" \"\n    return content\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.comments.get_comment","title":"<code>get_comment(key: CommentKey, for_notebook: bool) -&gt; str</code>","text":"<p>Get a comment string for some common keys.</p> <p>The key is a heading (in a notebook) or just a comment (in a script).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>agents | imports | skills | models | nested | run | logging</code> <p>The key.</p> required <code>for_notebook</code> <code>bool</code> <p>Whether the comment is for a notebook.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The comment string.</p> Example <pre><code>&gt;&gt;&gt; get_comment(\"agents\", True)\n\n'## Agents'\n&gt;&gt;&gt; get_comment(\"skills\", False)\n\n'# Skills'\n</code></pre> Source code in <code>waldiez/exporting/base/utils/comments.py</code> <pre><code>def get_comment(\n    key: CommentKey,\n    for_notebook: bool,\n) -&gt; str:\n    \"\"\"Get a comment string for some common keys.\n\n    The key is a heading (in a notebook) or just a comment (in a script).\n\n    Parameters\n    ----------\n    key : \"agents\"|\"imports\"|\"skills\"|\"models\"|\"nested\"|\"run\"|\"logging\"\n        The key.\n    for_notebook : bool\n        Whether the comment is for a notebook.\n\n    Returns\n    -------\n    str\n        The comment string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_comment(\"agents\", True)\n\n    '## Agents'\n    &gt;&gt;&gt; get_comment(\"skills\", False)\n\n    '# Skills'\n    ```\n    \"\"\"\n    # pylint: disable=too-many-return-statements\n    if key == \"agents\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Agents\\n\"\n    if key == \"imports\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Imports\\n\"\n    if key == \"skills\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Skills\\n\"\n    if key == \"models\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Models\\n\"\n    if key == \"nested\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Nested Chats\\n\"\n    if key == \"run\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Run the flow\\n\"\n    if key == \"logging\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Start Logging\\n\"\n    return comment(for_notebook)\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.get_comment","title":"<code>get_comment(key: CommentKey, for_notebook: bool) -&gt; str</code>","text":"<p>Get a comment string for some common keys.</p> <p>The key is a heading (in a notebook) or just a comment (in a script).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>agents | imports | skills | models | nested | run | logging</code> <p>The key.</p> required <code>for_notebook</code> <code>bool</code> <p>Whether the comment is for a notebook.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The comment string.</p> Example <pre><code>&gt;&gt;&gt; get_comment(\"agents\", True)\n\n'## Agents'\n&gt;&gt;&gt; get_comment(\"skills\", False)\n\n'# Skills'\n</code></pre> Source code in <code>waldiez/exporting/base/utils/comments.py</code> <pre><code>def get_comment(\n    key: CommentKey,\n    for_notebook: bool,\n) -&gt; str:\n    \"\"\"Get a comment string for some common keys.\n\n    The key is a heading (in a notebook) or just a comment (in a script).\n\n    Parameters\n    ----------\n    key : \"agents\"|\"imports\"|\"skills\"|\"models\"|\"nested\"|\"run\"|\"logging\"\n        The key.\n    for_notebook : bool\n        Whether the comment is for a notebook.\n\n    Returns\n    -------\n    str\n        The comment string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; get_comment(\"agents\", True)\n\n    '## Agents'\n    &gt;&gt;&gt; get_comment(\"skills\", False)\n\n    '# Skills'\n    ```\n    \"\"\"\n    # pylint: disable=too-many-return-statements\n    if key == \"agents\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Agents\\n\"\n    if key == \"imports\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Imports\\n\"\n    if key == \"skills\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Skills\\n\"\n    if key == \"models\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Models\\n\"\n    if key == \"nested\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Nested Chats\\n\"\n    if key == \"run\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Run the flow\\n\"\n    if key == \"logging\":\n        return \"\\n\" + comment(for_notebook, 2) + \"Start Logging\\n\"\n    return comment(for_notebook)\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.get_escaped_string","title":"<code>get_escaped_string(string: str) -&gt; str</code>","text":"<p>Get a string with escaped quotes and newlines.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The escaped string.</p> Source code in <code>waldiez/exporting/base/utils/naming.py</code> <pre><code>def get_escaped_string(string: str) -&gt; str:\n    \"\"\"Get a string with escaped quotes and newlines.\n\n    Parameters\n    ----------\n    string : str\n        The original string.\n\n    Returns\n    -------\n    str\n        The escaped string.\n    \"\"\"\n    return string.replace('\"', '\\\\\"').replace(\"\\n\", \"\\\\n\")\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.get_item_string","title":"<code>get_item_string(item: Any, tabs: int = 1) -&gt; str</code>","text":"<p>Convert an item to a formatted string with given indentation.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to convert.</p> required <code>tabs</code> <code>int</code> <p>The number of tabs, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The formatted string.</p> Example <pre><code>&gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3]}\n&gt;&gt;&gt; get_item_string(obj)\n{\n    \"a\": 1,\n    \"b\": [\n        1,\n        2,\n        3\n    ]\n}\n&gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3], \"c\": {\"d\": 4}}\n&gt;&gt;&gt; get_item_string(obj, 2)\n{\n        \"a\": 1,\n        \"b\": [\n            1,\n            2,\n            3\n        ],\n        \"c\": {\n            \"d\": 4\n        }\n}\n</code></pre> Source code in <code>waldiez/exporting/base/utils/to_string.py</code> <pre><code>def get_item_string(item: Any, tabs: int = 1) -&gt; str:\n    \"\"\"Convert an item to a formatted string with given indentation.\n\n    Parameters\n    ----------\n    item : Any\n        The item to convert.\n    tabs : int, optional\n        The number of tabs, by default 1.\n\n    Returns\n    -------\n    str\n        The formatted string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3]}\n    &gt;&gt;&gt; get_item_string(obj)\n    {\n        \"a\": 1,\n        \"b\": [\n            1,\n            2,\n            3\n        ]\n    }\n    &gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3], \"c\": {\"d\": 4}}\n    &gt;&gt;&gt; get_item_string(obj, 2)\n    {\n            \"a\": 1,\n            \"b\": [\n                1,\n                2,\n                3\n            ],\n            \"c\": {\n                \"d\": 4\n            }\n    }\n    ```\n    \"\"\"\n    indent = \" \" * 4 * tabs  # Number of spaces corresponding to the tabs\n    next_indent = (\n        \" \" * 4 * (tabs + 1)\n    )  # Number of spaces corresponding to the next tab level\n    if isinstance(item, dict):\n        items = []\n        for key, value in item.items():\n            items.append(\n                f'{next_indent}\"{key}\": {get_item_string(value, tabs + 1)}'\n            )\n        # python3.10? f-string expression part cannot include a backslash\n        items_string = \",\\n\".join(items)\n        to_return = \"\\n\" + items_string + \"\\n\" + indent\n        return f\"{{{to_return}}}\"\n    if isinstance(item, list):\n        items = []\n        for sub_item in item:\n            items.append(f\"{next_indent}{get_item_string(sub_item, tabs + 1)}\")\n        # python3.10? f-string expression part cannot include a backslash\n        items_string = \",\\n\".join(items)\n        to_return = \"\\n\" + items_string + \"\\n\" + indent\n        return f\"[{to_return}]\"\n\n    if isinstance(item, str):\n        if item.startswith(\"r'\") or item.startswith('r\"'):\n            return item\n        return f'\"{item}\"'\n\n    if item is None:\n        return \"None\"\n    return str(item)\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.get_path_string","title":"<code>get_path_string(path: str) -&gt; str</code>","text":"<p>Get the path string.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The string to check.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The local path string.</p> Source code in <code>waldiez/exporting/base/utils/path_check.py</code> <pre><code>def get_path_string(path: str) -&gt; str:\n    \"\"\"Get the path string.\n\n    Parameters\n    ----------\n    path : str\n        The string to check.\n\n    Returns\n    -------\n    str\n        The local path string.\n    \"\"\"\n    resolved = _check_local_path(path)\n    if not resolved:\n        return _get_raw_path_string(path)\n    return _get_raw_path_string(resolved)\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.get_valid_instance_name","title":"<code>get_valid_instance_name(instance: Tuple[str, str], current_names: Dict[str, str], prefix: str = 'w', max_length: int = MAX_VARIABLE_LENGTH) -&gt; Dict[str, str]</code>","text":"<p>Get a valid instance name.</p> <p>If the instance id is already in the current names nothing is done. If the name already exists in the current names,     the name is updated (with an index suffix).</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Tuple[str, str]</code> <p>The instance id and possible name.</p> required <code>current_names</code> <code>Dict[str, str]</code> <p>The current names.</p> required <code>prefix</code> <code>str</code> <p>The prefix to use if the name starts with a digit, if the name is already in the current names, or if the name is already in the current names with an index suffix.</p> <code>'w'</code> <code>max_length</code> <code>int</code> <p>The maximum length of the variable name.</p> <code>MAX_VARIABLE_LENGTH</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>The updated names.</p> Source code in <code>waldiez/exporting/base/utils/naming.py</code> <pre><code>def get_valid_instance_name(\n    instance: Tuple[str, str],\n    current_names: Dict[str, str],\n    prefix: str = \"w\",\n    max_length: int = MAX_VARIABLE_LENGTH,\n) -&gt; Dict[str, str]:\n    \"\"\"Get a valid instance name.\n\n    If the instance id is already in the current names nothing is done.\n    If the name already exists in the current names,\n        the name is updated (with an index suffix).\n\n    Parameters\n    ----------\n    instance : Tuple[str, str]\n        The instance id and possible name.\n    current_names : Dict[str, str]\n        The current names.\n    prefix : str, optional\n        The prefix to use if the name starts with a digit,\n        if the name is already in the current names,\n        or if the name is already in the current names with an index suffix.\n    max_length : int, optional\n        The maximum length of the variable name.\n\n    Returns\n    -------\n    Dict[str, str]\n        The updated names.\n    \"\"\"\n    instance_id, possible_name = instance[0], instance[1][:max_length]\n    if instance_id in current_names:\n        # already in the current names (it's id)\n        return current_names\n    new_names = current_names.copy()\n    name = get_valid_python_variable_name(\n        possible_name, prefix=prefix, max_length=max_length\n    )\n    if name in current_names.values():\n        name = f\"{prefix}_{name}\"\n    if name in current_names.values():\n        index = 1\n        while f\"{name}_{index}\" in current_names.values():\n            index += 1\n        name = f\"{name}_{index}\"\n    new_names[instance_id] = name\n    return new_names\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.naming","title":"<code>naming</code>","text":"<p>Utilities for naming.</p> <p>Functions:</p> Name Description <code>get_valid_python_variable_name</code> <p>Make sure a string is a valid Python variable name.</p> <code>get_valid_instance_name</code> <p>Get a valid instance name.</p> <code>get_escaped_string</code> <p>Get a string with escaped quotes and newlines.</p>"},{"location":"exporting/base/#waldiez.exporting.base.utils.naming.get_escaped_string","title":"<code>get_escaped_string(string: str) -&gt; str</code>","text":"<p>Get a string with escaped quotes and newlines.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The escaped string.</p> Source code in <code>waldiez/exporting/base/utils/naming.py</code> <pre><code>def get_escaped_string(string: str) -&gt; str:\n    \"\"\"Get a string with escaped quotes and newlines.\n\n    Parameters\n    ----------\n    string : str\n        The original string.\n\n    Returns\n    -------\n    str\n        The escaped string.\n    \"\"\"\n    return string.replace('\"', '\\\\\"').replace(\"\\n\", \"\\\\n\")\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.naming.get_valid_instance_name","title":"<code>get_valid_instance_name(instance: Tuple[str, str], current_names: Dict[str, str], prefix: str = 'w', max_length: int = MAX_VARIABLE_LENGTH) -&gt; Dict[str, str]</code>","text":"<p>Get a valid instance name.</p> <p>If the instance id is already in the current names nothing is done. If the name already exists in the current names,     the name is updated (with an index suffix).</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Tuple[str, str]</code> <p>The instance id and possible name.</p> required <code>current_names</code> <code>Dict[str, str]</code> <p>The current names.</p> required <code>prefix</code> <code>str</code> <p>The prefix to use if the name starts with a digit, if the name is already in the current names, or if the name is already in the current names with an index suffix.</p> <code>'w'</code> <code>max_length</code> <code>int</code> <p>The maximum length of the variable name.</p> <code>MAX_VARIABLE_LENGTH</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>The updated names.</p> Source code in <code>waldiez/exporting/base/utils/naming.py</code> <pre><code>def get_valid_instance_name(\n    instance: Tuple[str, str],\n    current_names: Dict[str, str],\n    prefix: str = \"w\",\n    max_length: int = MAX_VARIABLE_LENGTH,\n) -&gt; Dict[str, str]:\n    \"\"\"Get a valid instance name.\n\n    If the instance id is already in the current names nothing is done.\n    If the name already exists in the current names,\n        the name is updated (with an index suffix).\n\n    Parameters\n    ----------\n    instance : Tuple[str, str]\n        The instance id and possible name.\n    current_names : Dict[str, str]\n        The current names.\n    prefix : str, optional\n        The prefix to use if the name starts with a digit,\n        if the name is already in the current names,\n        or if the name is already in the current names with an index suffix.\n    max_length : int, optional\n        The maximum length of the variable name.\n\n    Returns\n    -------\n    Dict[str, str]\n        The updated names.\n    \"\"\"\n    instance_id, possible_name = instance[0], instance[1][:max_length]\n    if instance_id in current_names:\n        # already in the current names (it's id)\n        return current_names\n    new_names = current_names.copy()\n    name = get_valid_python_variable_name(\n        possible_name, prefix=prefix, max_length=max_length\n    )\n    if name in current_names.values():\n        name = f\"{prefix}_{name}\"\n    if name in current_names.values():\n        index = 1\n        while f\"{name}_{index}\" in current_names.values():\n            index += 1\n        name = f\"{name}_{index}\"\n    new_names[instance_id] = name\n    return new_names\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.naming.get_valid_python_variable_name","title":"<code>get_valid_python_variable_name(possible: str, prefix: str = 'w', max_length: int = MAX_VARIABLE_LENGTH) -&gt; str</code>","text":"<p>Get a valid Python variable name from a possible name.</p> <p>Parameters:</p> Name Type Description Default <code>possible</code> <code>str</code> <p>The possible name.</p> required <code>prefix</code> <code>str</code> <p>The prefix to use if the name starts with a digit or special character</p> <code>'w'</code> <code>max_length</code> <code>int</code> <p>The maximum length of the variable name.</p> <code>MAX_VARIABLE_LENGTH</code> <p>Returns:</p> Type Description <code>str</code> <p>The valid Python variable name.</p> Source code in <code>waldiez/exporting/base/utils/naming.py</code> <pre><code>def get_valid_python_variable_name(\n    possible: str,\n    prefix: str = \"w\",\n    max_length: int = MAX_VARIABLE_LENGTH,\n) -&gt; str:\n    \"\"\"Get a valid Python variable name from a possible name.\n\n    Parameters\n    ----------\n    possible : str\n        The possible name.\n\n    prefix : str, optional\n        The prefix to use if the name starts with a digit or special character\n\n    max_length : int, optional\n        The maximum length of the variable name.\n\n    Returns\n    -------\n    str\n        The valid Python variable name.\n    \"\"\"\n\n    def replacement(match: re.Match[str]) -&gt; str:\n        \"\"\"Get the replacement for the match.\n\n        Parameters\n        ----------\n        match : re.Match[str]\n            The match.\n\n        Returns\n        -------\n        str\n            The replacement\n        \"\"\"\n        if match.group(0) in [\"-&gt;\", \"=&gt;\"]:\n            return \"to\"\n        if match.group(0) in [\"&lt;-\", \"&lt;=\"]:\n            return \"from\"\n        if re.match(r\"\\W|^(?=\\d)\", match.group(0)):\n            return \"_\"\n        return match.group(0)\n\n    possible = re.sub(r\"-&gt;|=&gt;|&lt;-|&lt;=|\\W|^(?=\\d)\", replacement, possible)[\n        :max_length\n    ].lower()\n\n    if not possible:\n        return prefix + \"_\"\n    if possible.startswith(\"_\"):\n        return f\"{prefix}{possible}\"\n    if possible[0].isdigit():\n        return f\"{prefix}_{possible}\"\n    return possible\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.path_check","title":"<code>path_check</code>","text":"<p>Path check utility functions.</p>"},{"location":"exporting/base/#waldiez.exporting.base.utils.path_check.get_path_string","title":"<code>get_path_string(path: str) -&gt; str</code>","text":"<p>Get the path string.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The string to check.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The local path string.</p> Source code in <code>waldiez/exporting/base/utils/path_check.py</code> <pre><code>def get_path_string(path: str) -&gt; str:\n    \"\"\"Get the path string.\n\n    Parameters\n    ----------\n    path : str\n        The string to check.\n\n    Returns\n    -------\n    str\n        The local path string.\n    \"\"\"\n    resolved = _check_local_path(path)\n    if not resolved:\n        return _get_raw_path_string(path)\n    return _get_raw_path_string(resolved)\n</code></pre>"},{"location":"exporting/base/#waldiez.exporting.base.utils.to_string","title":"<code>to_string</code>","text":"<p>Utilities for converting items to strings.</p> <p>To be used with dicts and/or lists.</p>"},{"location":"exporting/base/#waldiez.exporting.base.utils.to_string.get_item_string","title":"<code>get_item_string(item: Any, tabs: int = 1) -&gt; str</code>","text":"<p>Convert an item to a formatted string with given indentation.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to convert.</p> required <code>tabs</code> <code>int</code> <p>The number of tabs, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The formatted string.</p> Example <pre><code>&gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3]}\n&gt;&gt;&gt; get_item_string(obj)\n{\n    \"a\": 1,\n    \"b\": [\n        1,\n        2,\n        3\n    ]\n}\n&gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3], \"c\": {\"d\": 4}}\n&gt;&gt;&gt; get_item_string(obj, 2)\n{\n        \"a\": 1,\n        \"b\": [\n            1,\n            2,\n            3\n        ],\n        \"c\": {\n            \"d\": 4\n        }\n}\n</code></pre> Source code in <code>waldiez/exporting/base/utils/to_string.py</code> <pre><code>def get_item_string(item: Any, tabs: int = 1) -&gt; str:\n    \"\"\"Convert an item to a formatted string with given indentation.\n\n    Parameters\n    ----------\n    item : Any\n        The item to convert.\n    tabs : int, optional\n        The number of tabs, by default 1.\n\n    Returns\n    -------\n    str\n        The formatted string.\n\n    Example\n    -------\n    ```python\n    &gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3]}\n    &gt;&gt;&gt; get_item_string(obj)\n    {\n        \"a\": 1,\n        \"b\": [\n            1,\n            2,\n            3\n        ]\n    }\n    &gt;&gt;&gt; obj = {\"a\": 1, \"b\": [1, 2, 3], \"c\": {\"d\": 4}}\n    &gt;&gt;&gt; get_item_string(obj, 2)\n    {\n            \"a\": 1,\n            \"b\": [\n                1,\n                2,\n                3\n            ],\n            \"c\": {\n                \"d\": 4\n            }\n    }\n    ```\n    \"\"\"\n    indent = \" \" * 4 * tabs  # Number of spaces corresponding to the tabs\n    next_indent = (\n        \" \" * 4 * (tabs + 1)\n    )  # Number of spaces corresponding to the next tab level\n    if isinstance(item, dict):\n        items = []\n        for key, value in item.items():\n            items.append(\n                f'{next_indent}\"{key}\": {get_item_string(value, tabs + 1)}'\n            )\n        # python3.10? f-string expression part cannot include a backslash\n        items_string = \",\\n\".join(items)\n        to_return = \"\\n\" + items_string + \"\\n\" + indent\n        return f\"{{{to_return}}}\"\n    if isinstance(item, list):\n        items = []\n        for sub_item in item:\n            items.append(f\"{next_indent}{get_item_string(sub_item, tabs + 1)}\")\n        # python3.10? f-string expression part cannot include a backslash\n        items_string = \",\\n\".join(items)\n        to_return = \"\\n\" + items_string + \"\\n\" + indent\n        return f\"[{to_return}]\"\n\n    if isinstance(item, str):\n        if item.startswith(\"r'\") or item.startswith('r\"'):\n            return item\n        return f'\"{item}\"'\n\n    if item is None:\n        return \"None\"\n    return str(item)\n</code></pre>"},{"location":"exporting/chats/","title":"Chats","text":"<p>Chats exporter.</p>"},{"location":"exporting/chats/#waldiez.exporting.chats.chats_exporter.ChatsExporter","title":"<code>ChatsExporter(get_swarm_members: Callable[[WaldiezAgent], Tuple[List[WaldiezAgent], Optional[WaldiezAgent]]], all_agents: List[WaldiezAgent], agent_names: Dict[str, str], all_chats: List[WaldiezChat], chat_names: Dict[str, str], main_chats: List[Tuple[WaldiezChat, WaldiezAgent, WaldiezAgent]], for_notebook: bool, is_async: bool)</code>","text":"<p>               Bases: <code>BaseExporter</code>, <code>ExporterMixin</code></p> <p>Chats exporter.</p> <p>Parameters:</p> Name Type Description Default <code>get_swarm_members</code> <code>Callable[</code> <pre><code>[WaldiezAgent],\nTuple[List[WaldiezAgent], Optional[WaldiezAgent]]\n</code></pre> <p>] The function to use to resolve the swarm members.</p> required <code>all_agents</code> <code>List[WaldiezAgent]</code> <p>All the agents in the flow.</p> required <code>agent_names</code> <code>Dict[str, str]</code> <p>A mapping of agent id to agent name.</p> required <code>all_chats</code> <code>List[WaldiezChat]</code> <p>All the chats in the flow.</p> required <code>chat_names</code> <code>Dict[str, str]</code> <p>A mapping of chat id to chat name.</p> required <code>main_chats</code> <code>List[Tuple[WaldiezChat, WaldiezAgent, WaldiezAgent]]</code> <p>The main chats in the flow.</p> required <code>for_notebook</code> <code>bool</code> <p>Whether the export is for a notebook.</p> required <code>is_async</code> <code>bool</code> <p>Whether the chat is asynchronous.</p> required Source code in <code>waldiez/exporting/chats/chats_exporter.py</code> <pre><code>def __init__(\n    self,\n    get_swarm_members: Callable[\n        [WaldiezAgent], Tuple[List[WaldiezAgent], Optional[WaldiezAgent]]\n    ],\n    all_agents: List[WaldiezAgent],\n    agent_names: Dict[str, str],\n    all_chats: List[WaldiezChat],\n    chat_names: Dict[str, str],\n    main_chats: List[Tuple[WaldiezChat, WaldiezAgent, WaldiezAgent]],\n    for_notebook: bool,\n    is_async: bool,\n):\n    \"\"\"Initialize the chats exporter.\n\n    Parameters\n    ----------\n    get_swarm_members : Callable[\n            [WaldiezAgent],\n            Tuple[List[WaldiezAgent], Optional[WaldiezAgent]]\n        ]\n        The function to use to resolve the swarm members.\n    all_agents : List[WaldiezAgent]\n        All the agents in the flow.\n    agent_names : Dict[str, str]\n        A mapping of agent id to agent name.\n    all_chats : List[WaldiezChat]\n        All the chats in the flow.\n    chat_names : Dict[str, str]\n        A mapping of chat id to chat name.\n    main_chats : List[Tuple[WaldiezChat, WaldiezAgent, WaldiezAgent]]\n        The main chats in the flow.\n    for_notebook : bool\n        Whether the export is for a notebook.\n    is_async : bool\n        Whether the chat is asynchronous.\n    \"\"\"\n    self.all_agents = all_agents\n    self.agent_names = agent_names\n    self.main_chats = main_chats\n    self.all_chats = all_chats\n    self.chat_names = chat_names\n    self.get_swarm_members = get_swarm_members\n    self.for_notebook = for_notebook\n    self.is_async = is_async\n    self._chat_string = None\n    self._before_chat = None\n    self._generated = False\n</code></pre>"},{"location":"exporting/chats/#waldiez.exporting.chats.chats_exporter.ChatsExporter.export","title":"<code>export() -&gt; ExporterReturnType</code>","text":"<p>Export the chats.</p> <p>Returns:</p> Type Description <code>ExporterReturnType</code> <p>The exported chats, the imports, the before export strings, the after export strings, and the environment variables.</p> Source code in <code>waldiez/exporting/chats/chats_exporter.py</code> <pre><code>def export(self) -&gt; ExporterReturnType:\n    \"\"\"Export the chats.\n\n    Returns\n    -------\n    ExporterReturnType\n        The exported chats, the imports, the before export strings,\n        the after export strings, and the environment variables.\n    \"\"\"\n    exported_string = self.generate()\n    imports = self.get_imports()\n    before_export = self.get_before_export()\n    after_export = self.get_after_export()\n    return {\n        \"content\": exported_string,\n        \"imports\": imports,\n        \"before_export\": before_export,\n        \"after_export\": after_export,\n        \"environment_variables\": None,\n    }\n</code></pre>"},{"location":"exporting/chats/#waldiez.exporting.chats.chats_exporter.ChatsExporter.generate","title":"<code>generate() -&gt; str</code>","text":"<p>Generate the chats content.</p> <p>Returns:</p> Type Description <code>str</code> <p>The chats content.</p> Source code in <code>waldiez/exporting/chats/chats_exporter.py</code> <pre><code>def generate(self) -&gt; str:\n    \"\"\"Generate the chats content.\n\n    Returns\n    -------\n    str\n        The chats content.\n    \"\"\"\n    if self._generated is False:\n        self._export_chats()\n        self._generated = True\n    return self._chat_string or \"\"\n</code></pre>"},{"location":"exporting/chats/#waldiez.exporting.chats.chats_exporter.ChatsExporter.get_after_export","title":"<code>get_after_export() -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code>","text":"<p>Generate the content after the main export.</p> <p>Returns:</p> Type Description <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The exported content after the main export and its position.</p> Source code in <code>waldiez/exporting/chats/chats_exporter.py</code> <pre><code>def get_after_export(\n    self,\n) -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]:\n    \"\"\"Generate the content after the main export.\n\n    Returns\n    -------\n    Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]\n        The exported content after the main export and its position.\n    \"\"\"\n    after: List[Tuple[str, Union[ExportPosition, AgentPosition]]] = []\n    # not per agent, we might have references to agents not yet defined.\n    # let's use one string for all nested chat registrations\n    nested_chat_registrations = \"\"\n    for agent in self.all_agents:\n        if agent.agent_type != \"swarm\":\n            registration_string = export_nested_chat_registration(\n                agent=agent,\n                all_chats=self.all_chats,\n                chat_names=self.chat_names,\n                agent_names=self.agent_names,\n                string_escape=self.string_escape,\n                serializer=self.serializer,\n                is_async=self.is_async,\n            )\n            if registration_string:\n                nested_chat_registrations += \"\\n\" + registration_string\n    if nested_chat_registrations:\n        # let's place it before the chats (after all agents are defined)\n        after.append(\n            (\n                nested_chat_registrations,\n                AgentPosition(None, AgentPositions.AFTER_ALL, 2),\n            )\n        )\n    return after\n</code></pre>"},{"location":"exporting/chats/#waldiez.exporting.chats.chats_exporter.ChatsExporter.get_before_export","title":"<code>get_before_export() -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code>","text":"<p>Generate the content before the main export.</p> <p>Returns:</p> Type Description <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The exported content before the main export and its position.</p> Source code in <code>waldiez/exporting/chats/chats_exporter.py</code> <pre><code>def get_before_export(\n    self,\n) -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]:\n    \"\"\"Generate the content before the main export.\n\n    Returns\n    -------\n    Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]\n        The exported content before the main export and its position.\n    \"\"\"\n    before: List[Tuple[str, Union[ExportPosition, AgentPosition]]] = []\n    if self._generated is False:\n        self._export_chats()\n        self._generated = True\n    if self._before_chat:\n        before.append(\n            (self._before_chat, ExportPosition(ExportPositions.CHATS))\n        )\n    return before\n</code></pre>"},{"location":"exporting/chats/#waldiez.exporting.chats.chats_exporter.ChatsExporter.get_imports","title":"<code>get_imports() -&gt; Optional[List[Tuple[str, ImportPosition]]]</code>","text":"<p>Get the imports string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The imports string.</p> Source code in <code>waldiez/exporting/chats/chats_exporter.py</code> <pre><code>def get_imports(self) -&gt; Optional[List[Tuple[str, ImportPosition]]]:\n    \"\"\"Get the imports string.\n\n    Returns\n    -------\n    str\n        The imports string.\n    \"\"\"\n    if len(self.main_chats) == 1:\n        _, sender, recipient = self.main_chats[0]\n        if sender.agent_type == \"swarm\" or recipient.agent_type == \"swarm\":\n            import_string = \"from autogen import initiate_swarm_chat\"\n            if self.is_async:\n                import_string = \"from autogen import a_initiate_swarm_chat\"\n            return [(import_string, ImportPosition.THIRD_PARTY)]\n        # no additional imports, it is `sender.initiate_chat(....)`\n        return None\n    if self.is_async:\n        import_string = (\n            \"from autogen.agentchat.chat import a_initiate_chats\"\n        )\n    else:\n        import_string = \"from autogen.agentchat.chat import initiate_chats\"\n    return [(import_string, ImportPosition.THIRD_PARTY)]\n</code></pre>"},{"location":"exporting/flow/","title":"Flow","text":"<p>Flow Exporter class.</p> <ul> <li>We gather all the exports (models, skills, agents, chats).</li> </ul> <ul> <li>We first add all the imports from the above exports.</li> <li>If we have skills, we include their imports.     (their files were generated when exporting the skills).</li> <li>Then, we write the all model configs.</li> <li>Next, we write the agent definitions     (using the <code>llm_config=...</code> argument from the model exports).</li> <li>If additional (nested_chats) are defined,     we write their registrations after all agents are defined.</li> <li>Next, we write the chat definitions     (using the agent names from the agent exports).</li> <li>If exporting to py,     we add the <code>run</code> function and the <code>def main()</code> to call the run function.</li> <li>If the flow is async, the <code>run</code> function is async.</li> </ul>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter","title":"<code>FlowExporter(waldiez: Waldiez, for_notebook: bool, output_dir: Optional[Union[str, Path]] = None)</code>","text":"<p>               Bases: <code>BaseExporter</code>, <code>ExporterMixin</code></p> <p>Flow exporter.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>def __init__(\n    self,\n    waldiez: Waldiez,\n    for_notebook: bool,\n    output_dir: Optional[Union[str, Path]] = None,\n) -&gt; None:\n    \"\"\"Initialize the flow exporter.\"\"\"\n    self.waldiez = waldiez\n    self.for_notebook = for_notebook\n    if output_dir is not None and not isinstance(output_dir, Path):\n        output_dir = Path(output_dir).resolve()\n    self.output_dir = output_dir\n    self.initialize()\n</code></pre>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter.initialize","title":"<code>initialize() -&gt; None</code>","text":"<p>Get all the names in the flow.</p> <p>We need to make sure that no duplicate names are used, and that the names can be used as python variables.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>def initialize(\n    self,\n) -&gt; None:\n    \"\"\"Get all the names in the flow.\n\n    We need to make sure that no duplicate names are used,\n    and that the names can be used as python variables.\n    \"\"\"\n    unique_names = ensure_unique_names(\n        self.waldiez,\n        self.get_valid_instance_name,\n    )\n    self.flow_name = unique_names[\"flow_name\"]\n    self.agents = unique_names[\"agents\"]\n    self.models = unique_names[\"models\"]\n    self.skills = unique_names[\"skills\"]\n    self.chats = unique_names[\"chats\"]\n    self.agent_names = unique_names[\"agent_names\"]\n    self.model_names = unique_names[\"model_names\"]\n    self.skill_names = unique_names[\"skill_names\"]\n    self.chat_names = unique_names[\"chat_names\"]\n</code></pre>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter.export_flow","title":"<code>export_flow() -&gt; ExporterReturnType</code>","text":"<p>Export the flow.</p> <p>Returns:</p> Type Description <code>ExporterReturnType</code> <p>The exported flow.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>def export_flow(self) -&gt; ExporterReturnType:\n    \"\"\"Export the flow.\n\n    Returns\n    -------\n    ExporterReturnType\n        The exported flow.\n    \"\"\"\n    models_output = self.export_models()\n    skills_output = self.export_skills()\n    chats_output = self.export_chats()\n    env_vars = self.gather_environment_variables(\n        model_env_vars=models_output[\"environment_variables\"],\n        skill_env_vars=skills_output[\"environment_variables\"],\n        chat_env_vars=chats_output[\"environment_variables\"],\n    )\n    before_export = self.gather_exports(\n        model_export=models_output[\"before_export\"],\n        skill_export=skills_output[\"before_export\"],\n        chat_export=chats_output[\"before_export\"],\n    )\n    after_export = self.gather_exports(\n        model_export=models_output[\"after_export\"],\n        skill_export=skills_output[\"after_export\"],\n        chat_export=chats_output[\"after_export\"],\n    )\n    # agents last (to make sure we have any needed arguments)\n    # like `llm_config=...` from the models\n    agents_output = self.export_agents(\n        before_export=before_export,\n        after_export=after_export,\n    )\n    imports = gather_imports(\n        model_imports=models_output[\"imports\"],\n        skill_imports=skills_output[\"imports\"],\n        chat_imports=chats_output[\"imports\"],\n        agent_imports=agents_output[\"imports\"],\n    )\n    if agents_output[\"environment_variables\"]:\n        env_vars.extend(agents_output[\"environment_variables\"])\n    if agents_output[\"before_export\"]:\n        before_export.extend(agents_output[\"before_export\"])\n    if agents_output[\"after_export\"]:\n        after_export.extend(agents_output[\"after_export\"])\n    all_imports = (\n        get_the_imports_string(imports, is_async=self.waldiez.is_async),\n        ImportPosition.LOCAL,\n    )\n    before_chats_export = chats_output[\"before_export\"] or []\n    content_before_chats = [\n        x[0]\n        for x in before_chats_export\n        if isinstance(x[1], ExportPosition)\n        and x[1].position == ExportPositions.CHATS\n    ]\n    before_chats = \"\\n\".join(content_before_chats)\n    content = self.merge_exports(\n        imports=all_imports,\n        models_output=models_output[\"content\"] or \"\",\n        skills_output=skills_output[\"content\"] or \"\",\n        agents_content=agents_output[\"content\"] or \"\",\n        chats_content=chats_output[\"content\"] or \"\",\n        before_chats=before_chats,\n    )\n    return {\n        \"content\": content,\n        \"imports\": [all_imports],\n        \"after_export\": after_export,\n        \"before_export\": before_export,\n        \"environment_variables\": env_vars,\n    }\n</code></pre>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter.merge_exports","title":"<code>merge_exports(imports: Tuple[str, ImportPosition], models_output: str, skills_output: str, agents_content: str, chats_content: str, before_chats: str) -&gt; str</code>","text":"<p>Merge all the export contents.</p> <p>Parameters:</p> Name Type Description Default <code>imports</code> <code>Tuple[str, ImportPosition]</code> <p>The imports.</p> required <code>models_output</code> <code>str</code> <p>The models output.</p> required <code>skills_output</code> <code>str</code> <p>The skills output.</p> required <code>agents_content</code> <code>str</code> <p>The agents content.</p> required <code>chats_content</code> <code>str</code> <p>The chats content.</p> required <code>before_chats</code> <code>str</code> required <p>Returns:</p> Type Description <code>str</code> <p>The merged export contents.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>def merge_exports(\n    self,\n    imports: Tuple[str, ImportPosition],\n    models_output: str,\n    skills_output: str,\n    agents_content: str,\n    chats_content: str,\n    before_chats: str,\n) -&gt; str:\n    \"\"\"Merge all the export contents.\n\n    Parameters\n    ----------\n    imports : Tuple[str, ImportPosition]\n        The imports.\n    models_output : str\n        The models output.\n    skills_output : str\n        The skills output.\n    agents_content : str\n        The agents content.\n    chats_content : str\n        The chats content.\n    before_chats : str\n    Returns\n    -------\n    str\n        The merged export contents.\n    \"\"\"\n    is_async = self.waldiez.is_async\n    cache_seed = self.waldiez.cache_seed\n    content = (\n        get_py_content_start(self.waldiez)\n        if not self.for_notebook\n        else get_ipynb_content_start(self.waldiez, comment=self.comment)\n    )\n    content += self.get_comment(\"imports\", self.for_notebook) + \"\\n\"\n    content += imports[0] + \"\\n\"\n    content += self.get_comment(\"logging\", self.for_notebook) + \"\\n\"\n    content += get_start_logging(tabs=0) + \"\\n\"\n    content += \"start_logging()\\n\\n\"\n    if models_output:\n        content += self.get_comment(\"models\", self.for_notebook) + \"\\n\"\n        content += models_output + \"\\n\"\n    if skills_output:\n        content += self.get_comment(\"skills\", self.for_notebook) + \"\\n\"\n        content += skills_output + \"\\n\"\n    if agents_content:\n        content += self.get_comment(\"agents\", self.for_notebook) + \"\\n\"\n        content += agents_content + \"\\n\"\n    if before_chats:\n        content += before_chats + \"\\n\"\n    content += get_sqlite_out(is_async=is_async) + \"\\n\"\n    content += get_stop_logging(tabs=0, is_async=is_async) + \"\\n\"\n    content += self.get_comment(\"run\", self.for_notebook) + \"\\n\"\n    after_run = get_after_run_content(\n        waldiez=self.waldiez,\n        agent_names=self.agent_names,\n        tabs=0 if self.for_notebook else 1,\n    )\n    if self.for_notebook is False:\n        content += get_def_main(\n            chats_content,\n            after_run=after_run,\n            is_async=self.waldiez.is_async,\n            cache_seed=cache_seed,\n        )\n    else:\n        if chats_content.startswith(\"\\n\"):\n            chats_content = chats_content[1:]\n        content += (\n            \"\\n\" + f\"with Cache.disk(cache_seed={cache_seed}) as cache:\"\n            \"\\n\" + chats_content + \"\\n\"\n        )\n        if is_async:\n            content += \"await stop_logging()\"\n        else:\n            content += \"stop_logging()\"\n            content += after_run\n    content = content.replace(\"\\n\\n\\n\\n\", \"\\n\\n\\n\")\n    return content\n</code></pre>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter.gather_environment_variables","title":"<code>gather_environment_variables(model_env_vars: Optional[List[Tuple[str, str]]], skill_env_vars: Optional[List[Tuple[str, str]]], chat_env_vars: Optional[List[Tuple[str, str]]]) -&gt; List[Tuple[str, str]]</code>  <code>staticmethod</code>","text":"<p>Gather all the environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>model_env_vars</code> <code>Optional[List[Tuple[str, str]]]</code> <p>The model environment variables.</p> required <code>skill_env_vars</code> <code>Optional[List[Tuple[str, str]]]</code> <p>The skill environment variables.</p> required <code>chat_env_vars</code> <code>Optional[List[Tuple[str, str]]]</code> <p>The chat environment variables.</p> required <p>Returns:</p> Type Description <code>List[Tuple[str, str]]</code> <p>The gathered environment variables.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>@staticmethod\ndef gather_environment_variables(\n    model_env_vars: Optional[List[Tuple[str, str]]],\n    skill_env_vars: Optional[List[Tuple[str, str]]],\n    chat_env_vars: Optional[List[Tuple[str, str]]],\n) -&gt; List[Tuple[str, str]]:\n    \"\"\"\n    Gather all the environment variables.\n\n    Parameters\n    ----------\n    model_env_vars : Optional[List[Tuple[str, str]]]\n        The model environment variables.\n    skill_env_vars : Optional[List[Tuple[str, str]]]\n        The skill environment variables.\n    chat_env_vars : Optional[List[Tuple[str, str]]]\n        The chat environment variables.\n\n    Returns\n    -------\n    List[Tuple[str, str]]\n        The gathered environment variables.\n    \"\"\"\n    all_env_vars: List[Tuple[str, str]] = []\n    if model_env_vars:\n        all_env_vars.extend(model_env_vars)\n    if skill_env_vars:\n        all_env_vars.extend(skill_env_vars)\n    if chat_env_vars:\n        all_env_vars.extend(chat_env_vars)\n    return all_env_vars\n</code></pre>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter.gather_exports","title":"<code>gather_exports(model_export: Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]], skill_export: Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]], chat_export: Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]) -&gt; List[Tuple[str, Union[ExportPosition, AgentPosition]]]</code>  <code>staticmethod</code>","text":"<p>Gather all (but agents) the before or after exports.</p> <p>Parameters:</p> Name Type Description Default <code>model_export</code> <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The model exports.</p> required <code>skill_export</code> <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The skill exports.</p> required <code>chat_export</code> <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The chat exports.</p> required <p>Returns:</p> Type Description <code>List[Tuple[str, Union[ExportPosition, AgentPosition]]]</code> <p>The gathered exports.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>@staticmethod\ndef gather_exports(\n    model_export: Optional[\n        List[Tuple[str, Union[ExportPosition, AgentPosition]]]\n    ],\n    skill_export: Optional[\n        List[Tuple[str, Union[ExportPosition, AgentPosition]]]\n    ],\n    chat_export: Optional[\n        List[Tuple[str, Union[ExportPosition, AgentPosition]]]\n    ],\n) -&gt; List[Tuple[str, Union[ExportPosition, AgentPosition]]]:\n    \"\"\"Gather all (but agents) the before or after exports.\n\n    Parameters\n    ----------\n    model_export : Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]\n        The model exports.\n    skill_export : Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]\n        The skill exports.\n    chat_export : Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]\n        The chat exports.\n\n    Returns\n    -------\n    List[Tuple[str, Union[ExportPosition, AgentPosition]]]\n        The gathered exports.\n    \"\"\"\n    all_exports: List[Tuple[str, Union[ExportPosition, AgentPosition]]] = []\n    if model_export:\n        all_exports.extend(model_export)\n    if skill_export:\n        all_exports.extend(skill_export)\n    if chat_export:\n        all_exports.extend(chat_export)\n    return all_exports\n</code></pre>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter.export_models","title":"<code>export_models() -&gt; ExporterReturnType</code>","text":"<p>Export the models.</p> <p>Returns:</p> Type Description <code>str</code> <p>The exported models.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>def export_models(self) -&gt; ExporterReturnType:\n    \"\"\"Export the models.\n\n    Returns\n    -------\n    str\n        The exported models.\n    \"\"\"\n    exporter = ModelsExporter(\n        flow_name=self.flow_name,\n        agents=self.agents,\n        agent_names=self.agent_names,\n        models=self.models,\n        model_names=self.model_names,\n        for_notebook=self.for_notebook,\n        output_dir=self.output_dir,\n        cache_seed=self.waldiez.cache_seed,\n    )\n    return exporter.export()\n</code></pre>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter.export_skills","title":"<code>export_skills() -&gt; ExporterReturnType</code>","text":"<p>Export the skills.</p> <p>Returns:</p> Type Description <code>str</code> <p>The exported skills.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>def export_skills(self) -&gt; ExporterReturnType:\n    \"\"\"Export the skills.\n\n    Returns\n    -------\n    str\n        The exported skills.\n    \"\"\"\n    exporter = SkillsExporter(\n        flow_name=self.flow_name,\n        agents=self.agents,\n        agent_names=self.agent_names,\n        skills=self.skills,\n        skill_names=self.skill_names,\n        output_dir=self.output_dir,\n    )\n    return exporter.export()\n</code></pre>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter.gather_agent_arguments","title":"<code>gather_agent_arguments(before_export: List[Tuple[str, Union[ExportPosition, AgentPosition]]], after_export: List[Tuple[str, Union[ExportPosition, AgentPosition]]]) -&gt; List[Tuple[str, AgentPosition]]</code>  <code>staticmethod</code>","text":"<p>Gather the agent arguments.</p> <p>Parameters:</p> Name Type Description Default <code>before_export</code> <code>List[Tuple[str, Union[ExportPosition, AgentPosition]]]</code> <p>The before export.</p> required <code>after_export</code> <code>List[Tuple[str, Union[ExportPosition, AgentPosition]]]</code> <p>The after export.</p> required <p>Returns:</p> Type Description <code>List[Tuple[str, AgentPosition]]</code> <p>The gathered agent arguments.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>@staticmethod\ndef gather_agent_arguments(\n    before_export: List[Tuple[str, Union[ExportPosition, AgentPosition]]],\n    after_export: List[Tuple[str, Union[ExportPosition, AgentPosition]]],\n) -&gt; List[Tuple[str, AgentPosition]]:\n    \"\"\"Gather the agent arguments.\n\n    Parameters\n    ----------\n    before_export : List[Tuple[str, Union[ExportPosition, AgentPosition]]]\n        The before export.\n    after_export : List[Tuple[str, Union[ExportPosition, AgentPosition]]]\n        The after export.\n\n    Returns\n    -------\n    List[Tuple[str, AgentPosition]]\n        The gathered agent arguments.\n    \"\"\"\n    exported_with_agent_arg: List[Tuple[str, AgentPosition]] = []\n    for before in before_export:\n        position = before[1]\n        if (\n            isinstance(position, AgentPosition)\n            and position.position == AgentPositions.AS_ARGUMENT\n        ):\n            exported_with_agent_arg.append((before[0], position))\n    for after in after_export:\n        position = after[1]\n        if (\n            isinstance(position, AgentPosition)\n            and position.position == AgentPositions.AS_ARGUMENT\n        ):\n            exported_with_agent_arg.append((after[0], position))\n    return exported_with_agent_arg\n</code></pre>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter.export_agents","title":"<code>export_agents(before_export: List[Tuple[str, Union[ExportPosition, AgentPosition]]], after_export: List[Tuple[str, Union[ExportPosition, AgentPosition]]]) -&gt; ExporterReturnType</code>","text":"<p>Export the agents.</p> <p>Parameters:</p> Name Type Description Default <code>before_export</code> <code>List[Tuple[str, Union[ExportPosition, AgentPosition]]]</code> <p>The before export.</p> required <code>after_export</code> <code>List[Tuple[str, Union[ExportPosition, AgentPosition]]]</code> <p>The after export.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The exported agents.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>def export_agents(\n    self,\n    before_export: List[Tuple[str, Union[ExportPosition, AgentPosition]]],\n    after_export: List[Tuple[str, Union[ExportPosition, AgentPosition]]],\n) -&gt; ExporterReturnType:\n    \"\"\"Export the agents.\n\n    Parameters\n    ----------\n    before_export : List[Tuple[str, Union[ExportPosition, AgentPosition]]]\n        The before export.\n    after_export : List[Tuple[str, Union[ExportPosition, AgentPosition]]]\n        The after export.\n    Returns\n    -------\n    str\n        The exported agents.\n    \"\"\"\n    agent_outputs = []\n    for agent in self.agents:\n        exported_with_agent_arg = self.gather_agent_arguments(\n            before_export, after_export\n        )\n        arguments_resolver = partial(\n            self.agent_arguments_resolver,\n            exported_with_agent_arg,\n        )\n        group_chat_members = self.waldiez.get_group_chat_members(agent)\n        exporter = AgentExporter(\n            agent=agent,\n            agent_names=self.agent_names,\n            models=(self.models, self.model_names),\n            chats=(self.chats, self.chat_names),\n            skill_names=self.skill_names,\n            is_async=self.waldiez.is_async,\n            for_notebook=self.for_notebook,\n            output_dir=self.output_dir,\n            group_chat_members=group_chat_members,\n            arguments_resolver=arguments_resolver,\n        )\n        agent_output = exporter.export()\n        agent_content = agent_output[\"content\"] or \"\"\n        after_agent_export = agent_output[\"after_export\"]\n        if after_agent_export:\n            after_export.extend(after_agent_export)\n        before_agent_export = agent_output[\"before_export\"]\n        if before_agent_export:\n            before_export.extend(before_agent_export)\n        if agent_content:\n            agent_content = add_before_agent_content(\n                agent_content,\n                before_export,\n                agent,\n            )\n            agent_content = add_after_agent_content(\n                agent_content,\n                after_export,\n                agent,\n            )\n        agent_output[\"content\"] = agent_content\n        agent_outputs.append(agent_output)\n    return gather_agent_outputs(\n        before_export=before_export,\n        after_export=after_export,\n        agent_outputs=agent_outputs,\n    )\n</code></pre>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter.agent_arguments_resolver","title":"<code>agent_arguments_resolver(additional_exports: List[Tuple[str, AgentPosition]], agent: WaldiezAgent) -&gt; List[str]</code>  <code>staticmethod</code>","text":"<p>Resolve the arguments for the agent.</p> <p>Parameters:</p> Name Type Description Default <code>additional_exports</code> <code>List[Tuple[str, AgentPosition]]</code> <p>The additional exports.</p> required <code>agent</code> <code>WaldiezAgent</code> <p>The agent.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The arguments for the agent.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>@staticmethod\ndef agent_arguments_resolver(\n    additional_exports: List[Tuple[str, AgentPosition]], agent: WaldiezAgent\n) -&gt; List[str]:\n    \"\"\"Resolve the arguments for the agent.\n\n    Parameters\n    ----------\n    additional_exports : List[Tuple[str, AgentPosition]]\n        The additional exports.\n    agent : WaldiezAgent\n        The agent.\n\n    Returns\n    -------\n    List[str]\n        The arguments for the agent.\n    \"\"\"\n    return [x[0] for x in additional_exports if x[1].agent == agent]\n</code></pre>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter.export_chats","title":"<code>export_chats() -&gt; ExporterReturnType</code>","text":"<p>Export the chats.</p> <p>Returns:</p> Type Description <code>str</code> <p>The exported chats.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>def export_chats(self) -&gt; ExporterReturnType:\n    \"\"\"Export the chats.\n\n    Returns\n    -------\n    str\n        The exported chats.\n    \"\"\"\n    exporter = ChatsExporter(\n        get_swarm_members=self.waldiez.get_swarm_members,\n        all_agents=self.agents,\n        agent_names=self.agent_names,\n        all_chats=self.chats,\n        chat_names=self.chat_names,\n        main_chats=self.waldiez.chats,\n        for_notebook=self.for_notebook,\n        is_async=self.waldiez.is_async,\n    )\n    output = exporter.export()\n    chat_contents = output[\"content\"] or \"\"\n    after_chats = output[\"after_export\"]\n    if chat_contents and after_chats:\n        chat_contents = add_after_chat_content(\n            chat_contents,\n            after_chats,\n        )\n    output[\"content\"] = chat_contents\n    return output\n</code></pre>"},{"location":"exporting/flow/#waldiez.exporting.flow.flow_exporter.FlowExporter.export","title":"<code>export() -&gt; ExporterReturnType</code>","text":"<p>Export the flow.</p> <p>Returns:</p> Type Description <code>SubExporterReturnType</code> <p>The exported flow.</p> Source code in <code>waldiez/exporting/flow/flow_exporter.py</code> <pre><code>def export(self) -&gt; ExporterReturnType:\n    \"\"\"Export the flow.\n\n    Returns\n    -------\n    SubExporterReturnType\n        The exported flow.\n    \"\"\"\n    return self.export_flow()\n</code></pre>"},{"location":"exporting/models/","title":"Models","text":"<p>Export models (llm_configs).</p>"},{"location":"exporting/models/#waldiez.exporting.models.models_exporter.ModelsExporter","title":"<code>ModelsExporter(flow_name: str, agents: List[WaldiezAgent], agent_names: Dict[str, str], models: List[WaldiezModel], model_names: Dict[str, str], for_notebook: bool, cache_seed: Optional[int], output_dir: Optional[Union[str, Path]] = None)</code>","text":"<p>               Bases: <code>BaseExporter</code>, <code>ExporterMixin</code></p> <p>Models exporter.</p> <p>Parameters:</p> Name Type Description Default <code>agents</code> <code>List[WaldiezAgent]</code> <p>The agents.</p> required <code>agent_names</code> <code>Dict[str, str]</code> <p>The agent names.</p> required <code>models</code> <code>List[WaldiezModel]</code> <p>The models.</p> required <code>model_names</code> <code>Dict[str, str]</code> <p>The model names.</p> required <code>for_notebook</code> <code>bool</code> <p>Whether the export is for a notebook or not.</p> required <code>cache_seed</code> <code>Optional[int]</code> <p>The cache seed if any, by default None</p> required <code>output_dir</code> <code>Optional[Union[str, Path]]</code> <p>The output directory if any, by default None</p> <code>None</code> Source code in <code>waldiez/exporting/models/models_exporter.py</code> <pre><code>def __init__(\n    self,\n    flow_name: str,\n    agents: List[WaldiezAgent],\n    agent_names: Dict[str, str],\n    models: List[WaldiezModel],\n    model_names: Dict[str, str],\n    for_notebook: bool,\n    cache_seed: Optional[int],\n    output_dir: Optional[Union[str, Path]] = None,\n) -&gt; None:\n    \"\"\"Initialize the models exporter.\n\n    Parameters\n    ----------\n    agents : List[WaldiezAgent]\n        The agents.\n    agent_names : Dict[str, str]\n        The agent names.\n    models : List[WaldiezModel]\n        The models.\n    model_names : Dict[str, str]\n        The model names.\n    for_notebook : bool\n        Whether the export is for a notebook or not.\n    cache_seed : Optional[int]\n        The cache seed if any, by default None\n    output_dir : Optional[Union[str, Path]], optional\n        The output directory if any, by default None\n    \"\"\"\n    self.for_notebook = for_notebook\n    self.flow_name = flow_name\n    self.agents = agents\n    self.agent_names = agent_names\n    self.models = models\n    self.model_names = model_names\n    if output_dir is not None and not isinstance(output_dir, Path):\n        output_dir = Path(output_dir)\n    self.cache_seed = cache_seed\n    self.output_dir = output_dir\n    self._exported_string = None\n</code></pre>"},{"location":"exporting/models/#waldiez.exporting.models.models_exporter.ModelsExporter.export","title":"<code>export() -&gt; ExporterReturnType</code>","text":"<p>Export the models.</p> <p>Returns:</p> Type Description <code>ExporterReturnType</code> <p>The exported models, the imports, the before export strings, the after export strings, and the environment variables.</p> Source code in <code>waldiez/exporting/models/models_exporter.py</code> <pre><code>def export(self) -&gt; ExporterReturnType:\n    \"\"\"Export the models.\n\n    Returns\n    -------\n    ExporterReturnType\n        The exported models,\n        the imports,\n        the before export strings,\n        the after export strings,\n        and the environment variables.\n    \"\"\"\n    exported_string = self.generate()\n    imports = self.get_imports()\n    after_export = self.get_after_export()\n    result: ExporterReturnType = {\n        \"content\": exported_string,\n        \"imports\": imports,\n        \"before_export\": None,\n        \"after_export\": after_export,\n        \"environment_variables\": None,\n    }\n    return result\n</code></pre>"},{"location":"exporting/models/#waldiez.exporting.models.models_exporter.ModelsExporter.generate","title":"<code>generate() -&gt; str</code>","text":"<p>Export the models.</p> <p>Returns:</p> Type Description <code>str</code> <p>The exported models.</p> Source code in <code>waldiez/exporting/models/models_exporter.py</code> <pre><code>def generate(self) -&gt; str:\n    \"\"\"Export the models.\n\n    Returns\n    -------\n    str\n        The exported models.\n    \"\"\"\n    if not self._exported_string:  # pragma: no cover\n        self._exported_string = export_models(\n            flow_name=self.flow_name,\n            all_models=self.models,\n            model_names=self.model_names,\n            output_dir=self.output_dir,\n            serializer=self.serializer,\n        )\n    return self._exported_string\n</code></pre>"},{"location":"exporting/models/#waldiez.exporting.models.models_exporter.ModelsExporter.get_after_export","title":"<code>get_after_export() -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code>","text":"<p>Generate the after export strings.</p> <p>The arguments for the agent's initialization. example generated args:</p> <p>agent1 = ConversableAgent(     ...     llm_config=False,     ... )</p> <p>agent2 = ConversableAgent(     ...     llm_config={         \"config_list\": [             model1_llm_config,             model2_llm_config,         ],     },     ... )</p> <p>where <code>model1_llm_config</code> and <code>model2_llm_config</code> are the exported models using <code>self.generate()</code></p> <p>Returns:</p> Type Description <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The exported after export strings and their positions.</p> Source code in <code>waldiez/exporting/models/models_exporter.py</code> <pre><code>def get_after_export(\n    self,\n) -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]:\n    # fmt: off\n    \"\"\"Generate the after export strings.\n\n    The arguments for the agent's initialization.\n    example generated args:\n    &gt;&gt;&gt; agent1 = ConversableAgent(\n    &gt;&gt;&gt;     ...\n    &gt;&gt;&gt;     llm_config=False,\n    &gt;&gt;&gt;     ...\n    &gt;&gt;&gt; )\n\n    &gt;&gt;&gt; agent2 = ConversableAgent(\n    &gt;&gt;&gt;     ...\n    &gt;&gt;&gt;     llm_config={\n    &gt;&gt;&gt;         \"config_list\": [\n    &gt;&gt;&gt;             model1_llm_config,\n    &gt;&gt;&gt;             model2_llm_config,\n    &gt;&gt;&gt;         ],\n    &gt;&gt;&gt;     },\n    &gt;&gt;&gt;     ...\n    &gt;&gt;&gt; )\n\n    where `model1_llm_config` and `model2_llm_config`\n    are the exported models using `self.generate()`\n\n    Returns\n    -------\n    Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]\n        The exported after export strings and their positions.\n    \"\"\"\n    # fmt: on\n    agent_llm_config_args: List[\n        Tuple[str, Union[ExportPosition, AgentPosition]]\n    ] = []\n    for agent in self.agents:\n        agent_llm_config_args.append(\n            (\n                get_agent_llm_config_arg(\n                    agent,\n                    all_models=self.models,\n                    model_names=self.model_names,\n                    cache_seed=self.cache_seed,\n                ),\n                AgentPosition(\n                    agent=agent, position=AgentPositions.AS_ARGUMENT\n                ),\n            )\n        )\n    return agent_llm_config_args\n</code></pre>"},{"location":"exporting/models/#waldiez.exporting.models.models_exporter.ModelsExporter.get_environment_variables","title":"<code>get_environment_variables() -&gt; Optional[List[Tuple[str, str]]]</code>","text":"<p>Get the environment variables to set.</p> <p>Returns:</p> Type Description <code>Optional[List[Tuple[str, str]]</code> <p>The environment variables to set.</p> Source code in <code>waldiez/exporting/models/models_exporter.py</code> <pre><code>def get_environment_variables(self) -&gt; Optional[List[Tuple[str, str]]]:\n    \"\"\"Get the environment variables to set.\n\n    Returns\n    -------\n    Optional[List[Tuple[str, str]]\n        The environment variables to set.\n    \"\"\"\n    env_vars = []\n    for model in self.models:\n        if model.api_key:\n            env_vars.append((model.api_key_env_key, model.api_key))\n    return env_vars\n</code></pre>"},{"location":"exporting/models/#waldiez.exporting.models.models_exporter.ModelsExporter.get_imports","title":"<code>get_imports() -&gt; Optional[List[Tuple[str, ImportPosition]]]</code>","text":"<p>Generate the imports string.</p> <p>Returns:</p> Type Description <code>Optional[Tuple[str, ImportPosition]]</code> <p>The exported imports and the position of the imports.</p> Source code in <code>waldiez/exporting/models/models_exporter.py</code> <pre><code>def get_imports(self) -&gt; Optional[List[Tuple[str, ImportPosition]]]:\n    \"\"\"Generate the imports string.\n\n    Returns\n    -------\n    Optional[Tuple[str, ImportPosition]]\n        The exported imports and the position of the imports.\n    \"\"\"\n    if not self.output_dir:\n        return None\n    file_path = self.output_dir / f\"{self.flow_name}_api_keys.py\"\n    if not file_path.exists():\n        # might be because the models are not exported yet\n        if not self._exported_string:\n            self.generate()\n        # if still not exported, return None\n        if not file_path.exists():  # pragma: no cover\n            return None\n    import_string = f\"from {self.flow_name}_api_keys import (\" + \"\\n\"\n    import_string += f\"    get_{self.flow_name}_model_api_key,\" + \"\\n\"\n    import_string += \")\\n\"\n    return [(import_string, ImportPosition.LOCAL)]\n</code></pre>"},{"location":"exporting/skills/","title":"Skills","text":"<p>Skills/tools related string generation functions.</p> <p>Functions:</p> Name Description <code>get_agent_skill_registration</code> <p>Get an agent's skill registration string.</p> <code>export_skills</code> <p>Get the skills content and secrets.</p>"},{"location":"exporting/skills/#waldiez.exporting.skills.skills_exporter.SkillsExporter","title":"<code>SkillsExporter(flow_name: str, agents: List[WaldiezAgent], agent_names: Dict[str, str], skills: List[WaldiezSkill], skill_names: Dict[str, str], output_dir: Optional[Union[str, Path]] = None)</code>","text":"<p>               Bases: <code>BaseExporter</code>, <code>ExporterMixin</code></p> <p>Skill exporter.</p> <p>Parameters:</p> Name Type Description Default <code>flow_name</code> <code>str</code> <p>The name of the flow.</p> required <code>agents</code> <code>List[WaldiezAgent]</code> <p>The agents.</p> required <code>agent_names</code> <code>Dict[str, str]</code> <p>The agent names.</p> required <code>skills</code> <code>List[WaldiezSkill]</code> <p>The skills.</p> required <code>skill_names</code> <code>Dict[str, str]</code> <p>The skill names.</p> required <code>output_dir</code> <code>Optional[Union[str, Path]]</code> <p>The output directory if any, by default None</p> <code>None</code> Source code in <code>waldiez/exporting/skills/skills_exporter.py</code> <pre><code>def __init__(\n    self,\n    flow_name: str,\n    agents: List[WaldiezAgent],\n    agent_names: Dict[str, str],\n    skills: List[WaldiezSkill],\n    skill_names: Dict[str, str],\n    output_dir: Optional[Union[str, Path]] = None,\n) -&gt; None:\n    \"\"\"Initialize the skill exporter.\n\n    Parameters\n    ----------\n    flow_name : str\n        The name of the flow.\n    agents : List[WaldiezAgent]\n        The agents.\n    agent_names : Dict[str, str]\n        The agent names.\n    skills : List[WaldiezSkill]\n        The skills.\n    skill_names : Dict[str, str]\n        The skill names.\n    output_dir : Optional[Union[str, Path]], optional\n        The output directory if any, by default None\n    \"\"\"\n    self.flow_name = flow_name\n    self.agents = agents\n    self.agent_names = agent_names\n    self.skills = skills\n    self.skill_names = skill_names\n    self.output_dir = output_dir\n    self.skill_imports, self.skill_secrets, self.skills_contents = (\n        export_skills(\n            flow_name=flow_name,\n            skills=skills,\n            skill_names=skill_names,\n            output_dir=output_dir,\n        )\n    )\n</code></pre>"},{"location":"exporting/skills/#waldiez.exporting.skills.skills_exporter.SkillsExporter.export","title":"<code>export() -&gt; ExporterReturnType</code>","text":"<p>Export the skills.</p> <p>Returns:</p> Type Description <code>ExporterReturnType</code> <p>The exported skills content, the imports, the before export strings, the after export strings, and the environment variables.</p> Source code in <code>waldiez/exporting/skills/skills_exporter.py</code> <pre><code>def export(self) -&gt; ExporterReturnType:\n    \"\"\"Export the skills.\n\n    Returns\n    -------\n    ExporterReturnType\n        The exported skills content, the imports,\n        the before export strings, the after export strings,\n        and the environment variables.\n    \"\"\"\n    content = self.generate()\n    imports = self.get_imports()\n    after_export = self.get_after_export()\n    environment_variables = self.get_environment_variables()\n    result: ExporterReturnType = {\n        \"content\": content,\n        \"imports\": imports,\n        \"before_export\": None,\n        \"after_export\": after_export,\n        \"environment_variables\": environment_variables,\n    }\n    return result\n</code></pre>"},{"location":"exporting/skills/#waldiez.exporting.skills.skills_exporter.SkillsExporter.generate","title":"<code>generate() -&gt; Optional[str]</code>","text":"<p>Generate the main export.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The exported content.</p> Source code in <code>waldiez/exporting/skills/skills_exporter.py</code> <pre><code>def generate(self) -&gt; Optional[str]:\n    \"\"\"Generate the main export.\n\n    Returns\n    -------\n    Optional[str]\n        The exported content.\n    \"\"\"\n    return self.skills_contents\n</code></pre>"},{"location":"exporting/skills/#waldiez.exporting.skills.skills_exporter.SkillsExporter.get_after_export","title":"<code>get_after_export() -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code>","text":"<p>Generate the content after the main export.</p> <p>Returns:</p> Type Description <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The exported content after the main export and its position.</p> Source code in <code>waldiez/exporting/skills/skills_exporter.py</code> <pre><code>def get_after_export(\n    self,\n) -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]:\n    \"\"\"Generate the content after the main export.\n\n    Returns\n    -------\n    Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]\n        The exported content after the main export and its position.\n    \"\"\"\n    agent_registrations: List[\n        Tuple[str, Union[ExportPosition, AgentPosition]]\n    ] = []\n    for agent in self.agents:\n        agent_registration = get_agent_skill_registrations(\n            agent=agent,\n            agent_names=self.agent_names,\n            all_skills=self.skills,\n            skill_names=self.skill_names,\n            string_escape=self.string_escape,\n        )\n        if agent_registration:\n            # after all agents since we use the executor\n            # (it might not yet be defined)\n            position = AgentPosition(None, AgentPositions.AFTER_ALL, 1)\n            agent_registrations.append((agent_registration, position))\n    return agent_registrations\n</code></pre>"},{"location":"exporting/skills/#waldiez.exporting.skills.skills_exporter.SkillsExporter.get_before_export","title":"<code>get_before_export() -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code>","text":"<p>Generate the content before the main export.</p> <p>Returns:</p> Type Description <code>Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]</code> <p>The exported content before the main export and its position.</p> Source code in <code>waldiez/exporting/skills/skills_exporter.py</code> <pre><code>def get_before_export(\n    self,\n) -&gt; Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]:\n    \"\"\"Generate the content before the main export.\n\n    Returns\n    -------\n    Optional[List[Tuple[str, Union[ExportPosition, AgentPosition]]]]\n        The exported content before the main export and its position.\n    \"\"\"\n</code></pre>"},{"location":"exporting/skills/#waldiez.exporting.skills.skills_exporter.SkillsExporter.get_environment_variables","title":"<code>get_environment_variables() -&gt; List[Tuple[str, str]]</code>","text":"<p>Get the environment variables to set.</p> <p>Returns:</p> Type Description <code>List[Tuple[str, str]]</code> <p>The environment variables to set.</p> Source code in <code>waldiez/exporting/skills/skills_exporter.py</code> <pre><code>def get_environment_variables(self) -&gt; List[Tuple[str, str]]:\n    \"\"\"Get the environment variables to set.\n\n    Returns\n    -------\n    List[Tuple[str, str]]\n        The environment variables to set.\n    \"\"\"\n    return self.skill_secrets\n</code></pre>"},{"location":"exporting/skills/#waldiez.exporting.skills.skills_exporter.SkillsExporter.get_imports","title":"<code>get_imports() -&gt; List[Tuple[str, ImportPosition]]</code>","text":"<p>\"Generate the imports string.</p> <p>Returns:</p> Type Description <code>Tuple[str, int]</code> <p>The exported imports and the position of the imports.</p> Source code in <code>waldiez/exporting/skills/skills_exporter.py</code> <pre><code>def get_imports(self) -&gt; List[Tuple[str, ImportPosition]]:\n    \"\"\" \"Generate the imports string.\n\n    Returns\n    -------\n    Tuple[str, int]\n        The exported imports and the position of the imports.\n    \"\"\"\n    imports: List[Tuple[str, ImportPosition]] = []\n    if not self.skill_imports:\n        return imports\n    # standard imports\n    for import_statement in self.skill_imports[0]:\n        imports.append((import_statement, ImportPosition.BUILTINS))\n    # third party imports\n    for import_statement in self.skill_imports[1]:\n        imports.append((import_statement, ImportPosition.THIRD_PARTY))\n    # secrets/local imports\n    for import_statement in self.skill_imports[2]:\n        imports.append((import_statement, ImportPosition.LOCAL))\n    return imports\n</code></pre>"},{"location":"models/chat/","title":"Chat","text":"<p>Waldiez chat model.</p> <p>Chat data model.</p> <p>Waldiez Message Model.</p> <p>Nested chat model.</p> <p>Waldiez chat summary options.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat","title":"<code>WaldiezChat</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Chat class.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The chat ID.</p> <code>data</code> <code>WaldiezChatData</code> <p>The chat data. See <code>waldiez.models.chat.WaldiezChatData</code> for more information.</p> <code>name</code> <code>str</code> <p>The chat name.</p> <code>source</code> <code>str</code> <p>The chat source.</p> <code>target</code> <code>str</code> <p>The chat target.</p> <code>nested_chat</code> <code>WaldiezChatNested</code> <p>The nested chat message/reply if any.</p> <code>message</code> <code>WaldiezChatMessage</code> <p>The chat message.</p> <code>message_content</code> <code>Optional[str]</code> <p>The chat message content if any. If method, the method's body.</p> <p>Methods:</p> Name Description <code>get_chat_args</code> <p>Get the chat arguments to use in autogen.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.after_work","title":"<code>after_work: Optional[WaldiezSwarmAfterWork]</code>  <code>property</code>","text":"<p>Get the after work.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.chat_id","title":"<code>chat_id: int</code>  <code>property</code>","text":"<p>Get the chat ID.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.context_variables","title":"<code>context_variables: Dict[str, Any]</code>  <code>property</code>","text":"<p>Get the context variables.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Get the description.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.get_chat_args","title":"<code>get_chat_args(for_queue: bool, sender: Optional[WaldiezAgent] = None) -&gt; Dict[str, Any]</code>","text":"<p>Get the chat arguments to use in autogen.</p> <p>Parameters:</p> Name Type Description Default <code>for_queue</code> <code>bool</code> <p>Whether to get the chat arguments for a chat queue.</p> required <code>sender</code> <code>WaldiezAgent</code> <p>The sender agent, to check if it's a RAG user.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>The chat arguments.</p> Source code in <code>waldiez/models/chat/chat.py</code> <pre><code>def get_chat_args(\n    self,\n    for_queue: bool,\n    sender: Optional[WaldiezAgent] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Get the chat arguments to use in autogen.\n\n    Parameters\n    ----------\n    for_queue : bool\n        Whether to get the chat arguments for a chat queue.\n    sender : WaldiezAgent, optional\n        The sender agent, to check if it's a RAG user.\n    Returns\n    -------\n    dict\n        The chat arguments.\n    \"\"\"\n    args_dict = self.data.get_chat_args(for_queue)\n    if (\n        isinstance(sender, WaldiezRagUser)\n        and sender.agent_type == \"rag_user\"\n        and self.message.type == \"rag_message_generator\"\n    ):\n        # check for n_results in agent data, to add in context\n        n_results = sender.data.retrieve_config.n_results\n        if isinstance(n_results, int) and n_results &gt; 0:\n            args_dict[\"n_results\"] = n_results\n    return args_dict\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.get_message_function","title":"<code>get_message_function(name_prefix: Optional[str] = None, name_suffix: Optional[str] = None, is_rag: bool = False) -&gt; Tuple[str, str]</code>","text":"<p>Get the message function.</p> <p>Parameters:</p> Name Type Description Default <code>name_prefix</code> <code>str</code> <p>The function name prefix.</p> <code>None</code> <code>name_suffix</code> <code>str</code> <p>The function name suffix.</p> <code>None</code> <code>is_rag</code> <code>bool</code> <p>If the message is from a RAG user.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The message function and the function name.</p> Source code in <code>waldiez/models/chat/chat.py</code> <pre><code>def get_message_function(\n    self,\n    name_prefix: Optional[str] = None,\n    name_suffix: Optional[str] = None,\n    is_rag: bool = False,\n) -&gt; Tuple[str, str]:\n    \"\"\"Get the message function.\n\n    Parameters\n    ----------\n    name_prefix : str\n        The function name prefix.\n    name_suffix : str\n        The function name suffix.\n    is_rag : bool\n        If the message is from a RAG user.\n\n    Returns\n    -------\n    Tuple[str, str]\n        The message function and the function name.\n    \"\"\"\n    if self.message.type in (\"string\", \"none\") or (\n        not self.message_content and is_rag is False\n    ):\n        return \"\", \"\"\n    function_types = CALLABLE_MESSAGE_TYPES\n    function_name = CALLABLE_MESSAGE\n    if name_prefix:\n        function_name = f\"{name_prefix}_{function_name}\"\n    if name_suffix:\n        function_name = f\"{function_name}_{name_suffix}\"\n    if is_rag and self.message.type == \"rag_message_generator\":\n        function_types = CALLABLE_MESSAGE_RAG_WITH_CARRYOVER_TYPES\n        return (\n            generate_function(\n                function_name=function_name,\n                function_args=CALLABLE_MESSAGE_ARGS,\n                function_types=function_types,\n                function_body=self.message.content_body\n                or RAG_METHOD_WITH_CARRYOVER_BODY,\n            ),\n            function_name,\n        )\n    return (\n        generate_function(\n            function_name=function_name,\n            function_args=CALLABLE_MESSAGE_ARGS,\n            function_types=function_types,\n            function_body=self.message_content or \"\",\n        ),\n        function_name,\n    )\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.get_nested_chat_message_function","title":"<code>get_nested_chat_message_function(name_prefix: Optional[str] = None, name_suffix: Optional[str] = None) -&gt; Tuple[str, str]</code>","text":"<p>Get the nested chat message function.</p> <p>Parameters:</p> Name Type Description Default <code>name_prefix</code> <code>str</code> <p>The function name prefix.</p> <code>None</code> <code>name_suffix</code> <code>str</code> <p>The function name suffix.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The nested chat message function and the function name.</p> Source code in <code>waldiez/models/chat/chat.py</code> <pre><code>def get_nested_chat_message_function(\n    self,\n    name_prefix: Optional[str] = None,\n    name_suffix: Optional[str] = None,\n) -&gt; Tuple[str, str]:\n    \"\"\"Get the nested chat message function.\n\n    Parameters\n    ----------\n    name_prefix : str\n        The function name prefix.\n    name_suffix : str\n        The function name suffix.\n\n    Returns\n    -------\n    Tuple[str, str]\n        The nested chat message function and the function name.\n    \"\"\"\n    if (\n        not self.nested_chat.message\n        or self.nested_chat.message.type in (\"string\", \"none\")\n        or not self.nested_chat.message_content\n    ):\n        return \"\", \"\"\n    function_name = NESTED_CHAT_MESSAGE\n    if name_prefix:\n        function_name = f\"{name_prefix}_{function_name}\"\n    if name_suffix:\n        function_name = f\"{function_name}_{name_suffix}\"\n    return (\n        generate_function(\n            function_name=function_name,\n            function_args=NESTED_CHAT_ARGS,\n            function_types=NESTED_CHAT_TYPES,\n            function_body=self.nested_chat.message_content,\n        ),\n        function_name,\n    )\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.get_nested_chat_reply_function","title":"<code>get_nested_chat_reply_function(name_prefix: Optional[str] = None, name_suffix: Optional[str] = None) -&gt; Tuple[str, str]</code>","text":"<p>Get the nested chat reply function.</p> <p>Parameters:</p> Name Type Description Default <code>name_prefix</code> <code>str</code> <p>The function name prefix.</p> <code>None</code> <code>name_suffix</code> <code>str</code> <p>The function name suffix.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The nested chat reply function and the function name.</p> Source code in <code>waldiez/models/chat/chat.py</code> <pre><code>def get_nested_chat_reply_function(\n    self,\n    name_prefix: Optional[str] = None,\n    name_suffix: Optional[str] = None,\n) -&gt; Tuple[str, str]:\n    \"\"\"Get the nested chat reply function.\n\n    Parameters\n    ----------\n    name_prefix : str\n        The function name prefix.\n    name_suffix : str\n        The function name suffix.\n\n    Returns\n    -------\n    Tuple[str, str]\n        The nested chat reply function and the function name.\n    \"\"\"\n    if (\n        not self.nested_chat.reply\n        or self.nested_chat.reply.type in (\"string\", \"none\")\n        or not self.nested_chat.reply_content\n    ):\n        return \"\", \"\"\n    function_name = NESTED_CHAT_REPLY\n    if name_prefix:\n        function_name = f\"{name_prefix}_{function_name}\"\n    if name_suffix:\n        function_name = f\"{function_name}_{name_suffix}\"\n    return (\n        generate_function(\n            function_name=function_name,\n            function_args=NESTED_CHAT_ARGS,\n            function_types=NESTED_CHAT_TYPES,\n            function_body=self.nested_chat.reply_content,\n        ),\n        function_name,\n    )\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.max_rounds","title":"<code>max_rounds: int</code>  <code>property</code>","text":"<p>Get the max rounds for swarm chat.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.message","title":"<code>message: WaldiezChatMessage</code>  <code>property</code>","text":"<p>Get the message.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.message_content","title":"<code>message_content: Optional[str]</code>  <code>property</code>","text":"<p>Get the message content.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.model_dump","title":"<code>model_dump(**kwargs: Any) -&gt; Dict[str, Any]</code>","text":"<p>Dump the model to a dict including the chat attributes.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Any</code> <p>The keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The model dump with the chat attributes.</p> Source code in <code>waldiez/models/chat/chat.py</code> <pre><code>def model_dump(self, **kwargs: Any) -&gt; Dict[str, Any]:\n    \"\"\"Dump the model to a dict including the chat attributes.\n\n    Parameters\n    ----------\n    kwargs : Any\n        The keyword arguments.\n    Returns\n    -------\n    Dict[str, Any]\n        The model dump with the chat attributes.\n    \"\"\"\n    dump = super().model_dump(**kwargs)\n    dump[\"name\"] = self.name\n    dump[\"description\"] = self.description\n    dump[\"source\"] = self.source\n    dump[\"target\"] = self.target\n    dump[\"nested_chat\"] = self.nested_chat.model_dump()\n    dump[\"message\"] = self.message.model_dump()\n    dump[\"message_content\"] = self.message_content\n    dump[\"context_variables\"] = self.context_variables\n    dump[\"max_rounds\"] = self.max_rounds\n    dump[\"after_work\"] = (\n        self.after_work.model_dump() if self.after_work else None\n    )\n    return dump\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get the name.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.nested_chat","title":"<code>nested_chat: WaldiezChatNested</code>  <code>property</code>","text":"<p>Get the nested chat.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.order","title":"<code>order: int</code>  <code>property</code>","text":"<p>Get the order.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.prerequisites","title":"<code>prerequisites: List[int]</code>  <code>property</code>","text":"<p>Get the chat prerequisites.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.set_chat_id","title":"<code>set_chat_id(value: int) -&gt; None</code>","text":"<p>Set the chat ID.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The chat ID.</p> required Source code in <code>waldiez/models/chat/chat.py</code> <pre><code>def set_chat_id(self, value: int) -&gt; None:\n    \"\"\"Set the chat ID.\n\n    Parameters\n    ----------\n    value : int\n        The chat ID.\n    \"\"\"\n    self.data.set_chat_id(value)\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.set_prerequisites","title":"<code>set_prerequisites(value: List[int]) -&gt; None</code>","text":"<p>Set the chat prerequisites.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>List[int]</code> <p>The chat prerequisites.</p> required Source code in <code>waldiez/models/chat/chat.py</code> <pre><code>def set_prerequisites(self, value: List[int]) -&gt; None:\n    \"\"\"Set the chat prerequisites.\n\n    Parameters\n    ----------\n    value : List[int]\n        The chat prerequisites.\n    \"\"\"\n    self.data.set_prerequisites(value)\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.source","title":"<code>source: str</code>  <code>property</code>","text":"<p>Get the source.</p>"},{"location":"models/chat/#waldiez.models.chat.chat.WaldiezChat.target","title":"<code>target: str</code>  <code>property</code>","text":"<p>Get the target.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldiezChatData","title":"<code>WaldiezChatData</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Chat data class.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the chat.</p> <code>source</code> <code>str</code> <p>The source of the chat (sender).</p> <code>target</code> <code>str</code> <p>The target of the chat (recipient).</p> <code>description</code> <code>str</code> <p>The description of the chat.</p> <code>position</code> <code>int</code> <p>The position of the chat. Ignored (UI related).</p> <code>order</code> <code>int</code> <p>The of the chat. If negative, ignored.</p> <code>clear_history</code> <code>(Optional[bool], optional)</code> <p>Whether to clear the chat history, by default None.</p> <code>message</code> <code>Union[str, WaldiezChatMessage]</code> <p>The message of the chat.</p> <code>nested_chat</code> <code>WaldiezChatNested</code> <p>The nested chat config.</p> <code>summary</code> <code>WaldiezChatSummary</code> <p>The summary method and options for the chat.</p> <code>max_turns</code> <code>Optional[int]</code> <p>The maximum number of turns for the chat, by default None (no limit).</p> <code>silent</code> <code>(Optional[bool], optional)</code> <p>Whether to run the chat silently, by default None (ignored).</p> <code>summary_args</code> <code>Optional[Dict[str, Any]]</code> <p>The summary args to use in autogen.</p> <code>real_source</code> <code>Optional[str]</code> <p>The real source of the chat (overrides the source).</p> <code>real_target</code> <code>Optional[str]</code> <p>The real target of the chat (overrides the target).</p> <code>max_rounds</code> <code>int</code> <p>Maximum number of conversation rounds (swarm).</p> <code>after_work</code> <code>Optional[WaldiezSwarmAfterWork]</code> <p>The work to do after the chat (swarm).</p> <p>Methods:</p> Name Description <code>validate_message</code> <p>Validate the message.</p> <code>validate_summary_method</code> <p>Validate the summary method.</p> <code>serialize_summary_method</code> <p>Serialize summary method.</p> <code>get_chat_args</code> <p>Get the chat arguments to use in autogen.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldiezChatData.get_chat_args","title":"<code>get_chat_args(for_queue: bool) -&gt; Dict[str, Any]</code>","text":"<p>Get the chat arguments to use in autogen.</p> <p>Without the 'message' key.</p> <p>Parameters:</p> Name Type Description Default <code>for_queue</code> <code>bool</code> <p>Whether to get the arguments for a chat queue.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The dictionary to pass as kwargs.</p> Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>def get_chat_args(self, for_queue: bool) -&gt; Dict[str, Any]:\n    \"\"\"Get the chat arguments to use in autogen.\n\n    Without the 'message' key.\n\n    Parameters\n    ----------\n    for_queue : bool\n        Whether to get the arguments for a chat queue.\n\n    Returns\n    -------\n    Dict[str, Any]\n        The dictionary to pass as kwargs.\n    \"\"\"\n    args: Dict[str, Any] = {}\n    if self.summary.method:\n        args[\"summary_method\"] = self.summary.method\n    if self.summary_args:\n        args[\"summary_args\"] = self.summary_args\n    if isinstance(self.max_turns, int) and self.max_turns &gt; 0:\n        args[\"max_turns\"] = self.max_turns\n    if isinstance(self.clear_history, bool):\n        args[\"clear_history\"] = self.clear_history\n    if isinstance(self.silent, bool):\n        args[\"silent\"] = self.silent\n    args.update(self._get_context_args())\n    if for_queue:\n        args[\"chat_id\"] = self._chat_id\n    if self._prerequisites:\n        args[\"prerequisites\"] = self._prerequisites\n    return args\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldiezChatData.get_chat_id","title":"<code>get_chat_id() -&gt; int</code>","text":"<p>Get the chat id.</p> <p>Returns:</p> Type Description <code>int</code> <p>The chat id.</p> Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>def get_chat_id(self) -&gt; int:\n    \"\"\"Get the chat id.\n\n    Returns\n    -------\n    int\n        The chat id.\n    \"\"\"\n    return self._chat_id\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldiezChatData.get_prerequisites","title":"<code>get_prerequisites() -&gt; List[int]</code>","text":"<p>Get the chat prerequisites.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>The chat prerequisites (if async).</p> Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>def get_prerequisites(self) -&gt; List[int]:\n    \"\"\"Get the chat prerequisites.\n\n    Returns\n    -------\n    List[int]\n        The chat prerequisites (if async).\n    \"\"\"\n    return self._prerequisites\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldiezChatData.message_content","title":"<code>message_content: Optional[str]</code>  <code>property</code>","text":"<p>Get the message content.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldiezChatData.set_chat_id","title":"<code>set_chat_id(value: int) -&gt; None</code>","text":"<p>Set the chat id.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The chat id.</p> required Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>def set_chat_id(self, value: int) -&gt; None:\n    \"\"\"Set the chat id.\n\n    Parameters\n    ----------\n    value : int\n        The chat id.\n    \"\"\"\n    self._chat_id = value\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldiezChatData.set_prerequisites","title":"<code>set_prerequisites(value: List[int]) -&gt; None</code>","text":"<p>Set the chat prerequisites.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>List[int]</code> <p>The chat prerequisites to set.</p> required Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>def set_prerequisites(self, value: List[int]) -&gt; None:\n    \"\"\"Set the chat prerequisites.\n\n    Parameters\n    ----------\n    value : List[int]\n        The chat prerequisites to set.\n    \"\"\"\n    self._prerequisites = value\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldiezChatData.summary_args","title":"<code>summary_args: Optional[Dict[str, Any]]</code>  <code>property</code>","text":"<p>Get the summary args.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldiezChatData.validate_chat_data","title":"<code>validate_chat_data() -&gt; Self</code>","text":"<p>Validate the chat data.</p> <p>Returns:</p> Type Description <code>WaldiezChatData</code> <p>The validated chat data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_chat_data(self) -&gt; Self:\n    \"\"\"Validate the chat data.\n\n    Returns\n    -------\n    WaldiezChatData\n        The validated chat data.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if not isinstance(self.message, WaldiezChatMessage):  # pragma: no cover\n        return self\n    self._message_content = self.message.content\n    if self.message.type == \"none\":\n        self._message_content = None\n    if self.message.type == \"string\":\n        self._message_content = self.message.content\n    if self.message.type == \"method\":\n        valid, error_or_body = check_function(\n            self.message.content or \"\",\n            CALLABLE_MESSAGE,\n            CALLABLE_MESSAGE_ARGS,\n        )\n        if not valid:\n            raise ValueError(error_or_body)\n        self._message_content = error_or_body\n    return self\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldiezChatData.validate_context_variables","title":"<code>validate_context_variables(value: Optional[Dict[str, Any]]) -&gt; Optional[Dict[str, Any]]</code>  <code>classmethod</code>","text":"<p>Validate the context variables.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[Dict[str, Any]]</code> <p>The context variables value.</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>The validated context variables value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>@field_validator(\"context_variables\", mode=\"after\")\n@classmethod\ndef validate_context_variables(\n    cls, value: Optional[Dict[str, Any]]\n) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Validate the context variables.\n\n    Parameters\n    ----------\n    value : Optional[Dict[str, Any]]\n        The context variables value.\n\n    Returns\n    -------\n    Optional[Dict[str, Any]]\n        The validated context variables value.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if value is None:\n        return None\n    return update_dict(value)\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_data.WaldiezChatData.validate_message","title":"<code>validate_message(value: Any) -&gt; WaldiezChatMessage</code>  <code>classmethod</code>","text":"<p>Validate the message.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The message value.</p> required <p>Returns:</p> Type Description <code>WaldiezChatMessage</code> <p>The validated message value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/chat/chat_data.py</code> <pre><code>@field_validator(\"message\", mode=\"before\")\n@classmethod\ndef validate_message(cls, value: Any) -&gt; WaldiezChatMessage:\n    \"\"\"Validate the message.\n\n    Parameters\n    ----------\n    value : Any\n        The message value.\n\n    Returns\n    -------\n    WaldiezChatMessage\n        The validated message value.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if value is None:\n        return WaldiezChatMessage(\n            type=\"none\", use_carryover=False, content=None, context={}\n        )\n    if isinstance(value, (str, int, float, bool)):\n        return WaldiezChatMessage(\n            type=\"string\",\n            use_carryover=False,\n            content=str(value),\n            context={},\n        )\n    if isinstance(value, dict):\n        return WaldiezChatMessage.model_validate(value)\n    if not isinstance(value, WaldiezChatMessage):\n        return WaldiezChatMessage(\n            type=\"none\", use_carryover=False, content=None, context={}\n        )\n    return value\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_message.WaldiezChatMessage","title":"<code>WaldiezChatMessage</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Message.</p> <p>A generic message with a type and content.</p> <p>If the type is not <code>none</code>, the content is a string. If the type is 'method', the content is the source code of a method. If the type is 'last_carryover', the content is a method to return     the last carryover from the context. If the type is 'rag_message_generator', and the sender is a RAG user agent,     the content will be generated by the <code>sender.message_generator</code> method.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>WaldiezChatMessageType</code> <p>The type of the message: - string - method - rag_message_generator - none If the sender is a RAG user agent, and the type is <code>rag_message_generator</code>, the <code>{sender}.message_generator</code> method will be used.</p> <code>content</code> <code>Optional[str]</code> <p>The content of the message (string or method).</p> <code>context</code> <code>Dict[str, Any]</code> <p>Extra context of the message.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_message.WaldiezChatMessage.content_body","title":"<code>content_body: Optional[str]</code>  <code>property</code>","text":"<p>Get the content body.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_message.WaldiezChatMessage.validate_content","title":"<code>validate_content() -&gt; Self</code>","text":"<p>Validate the content (if not a method).</p> <p>Returns:</p> Type Description <code>WaldiezChatMessage</code> <p>The validated instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the content is invalid.</p> Source code in <code>waldiez/models/chat/chat_message.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_content(self) -&gt; Self:\n    \"\"\"Validate the content (if not a method).\n\n    Returns\n    -------\n    WaldiezChatMessage\n        The validated instance.\n\n    Raises\n    ------\n    ValueError\n        If the content is invalid.\n    \"\"\"\n    content: Optional[str] = None\n    if self.type == \"none\":\n        content = \"None\"\n    if self.type == \"method\":\n        if not self.content:\n            raise ValueError(\n                \"The message content is required for the method type\"\n            )\n        content = self.content\n    if self.type == \"string\":\n        if not self.content:\n            self.content = \"\"\n        if self.use_carryover:\n            content = get_last_carryover_method_content(\n                text_content=self.content,\n            )\n        content = self.content\n    if self.type == \"rag_message_generator\":\n        if self.use_carryover:\n            content = get_last_carryover_method_content(\n                text_content=self.content or \"\",\n            )\n        else:\n            content = RAG_METHOD_WITH_CARRYOVER_BODY\n            self.content = RAG_METHOD_WITH_CARRYOVER\n    self._content_body = content\n    return self\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_message.WaldiezChatMessage.validate_context_vars","title":"<code>validate_context_vars() -&gt; Self</code>","text":"<p>Try to detect bools nulls and numbers from the context values.</p> <p>Returns:</p> Type Description <code>WaldiezChatMessage</code> <p>The validated instance.</p> Source code in <code>waldiez/models/chat/chat_message.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_context_vars(self) -&gt; Self:\n    \"\"\"Try to detect bools nulls and numbers from the context values.\n\n    Returns\n    -------\n    WaldiezChatMessage\n        The validated instance.\n    \"\"\"\n    self.context = update_dict(self.context)\n    return self\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_message.WaldiezChatMessage.validate_method","title":"<code>validate_method(function_name: str, function_args: List[str]) -&gt; str</code>","text":"<p>Validate a method.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>str</code> <p>The method name.</p> required <code>function_args</code> <code>List[str]</code> <p>The expected method arguments.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated method body.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/chat/chat_message.py</code> <pre><code>def validate_method(\n    self,\n    function_name: str,\n    function_args: List[str],\n) -&gt; str:\n    \"\"\"Validate a method.\n\n    Parameters\n    ----------\n    function_name : str\n        The method name.\n    function_args : List[str]\n        The expected method arguments.\n\n    Returns\n    -------\n    str\n        The validated method body.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if not self.content:\n        raise ValueError(\n            \"The message content is required for the method type\"\n        )\n    is_valid, error_or_body = check_function(\n        code_string=self.content,\n        function_name=function_name,\n        function_args=function_args,\n    )\n    if not is_valid:\n        raise ValueError(error_or_body)\n    return error_or_body\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_message.get_last_carryover_method_content","title":"<code>get_last_carryover_method_content(text_content: str) -&gt; str</code>","text":"<p>Get the last carryover method content.</p> <p>Parameters:</p> Name Type Description Default <code>text_content</code> <code>str</code> <p>Text content before the carryover.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The last carryover method content.</p> Source code in <code>waldiez/models/chat/chat_message.py</code> <pre><code>def get_last_carryover_method_content(text_content: str) -&gt; str:\n    \"\"\"Get the last carryover method content.\n\n    Parameters\n    ----------\n    text_content : str\n        Text content before the carryover.\n    Returns\n    -------\n    str\n        The last carryover method content.\n    \"\"\"\n    method_content = '''\n    \"\"\"Get the message to send using the last carryover.\n\n    Parameters\n    ----------\n    sender : ConversableAgent\n        The source agent.\n    recipient : ConversableAgent\n        The target agent.\n    context : Dict[str, Any]\n        The context.\n\n    Returns\n    -------\n    Union[Dict[str, Any], str]\n        The message to send using the last carryover.\n    \"\"\"\n    carryover = context.get(\"carryover\", \"\")\n    if isinstance(carryover, list):\n        carryover = carryover[-1]\n    if not isinstance(carryover, str):\n        if isinstance(carryover, list):\n            carryover = carryover[-1]\n        elif isinstance(carryover, dict):\n            carryover = carryover.get(\"content\", \"\")\n    if not isinstance(carryover, str):\n        carryover = \"\"'''\n    if text_content:\n        method_content += f\"\"\"\n    final_message = \"{text_content}\" + carryover\n    return final_message\n\"\"\"\n    else:\n        method_content += \"\"\"\n    return carryover\n\"\"\"\n    return method_content\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_nested.WaldiezChatNested","title":"<code>WaldiezChatNested</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Nested chat class.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>WaldiezChatMessage</code> <p>The message in a nested chat (sender -&gt; recipient).</p> <code>reply</code> <code>WaldiezChatMessage</code> <p>The reply in a nested chat (recipient -&gt; sender).</p>"},{"location":"models/chat/#waldiez.models.chat.chat_nested.WaldiezChatNested.message_content","title":"<code>message_content: Optional[str]</code>  <code>property</code>","text":"<p>Get the message content.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_nested.WaldiezChatNested.reply_content","title":"<code>reply_content: Optional[str]</code>  <code>property</code>","text":"<p>Get the reply content.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_nested.WaldiezChatNested.validate_message","title":"<code>validate_message(value: Any) -&gt; WaldiezChatMessage</code>  <code>classmethod</code>","text":"<p>Validate the message.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value.</p> required <p>Returns:</p> Type Description <code>WaldiezChatMessage</code> <p>The validated message.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/chat/chat_nested.py</code> <pre><code>@field_validator(\"message\", \"reply\", mode=\"before\")\n@classmethod\ndef validate_message(cls, value: Any) -&gt; WaldiezChatMessage:\n    \"\"\"Validate the message.\n\n    Parameters\n    ----------\n    value : Any\n        The value.\n\n    Returns\n    -------\n    WaldiezChatMessage\n        The validated message.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if not value:\n        return WaldiezChatMessage(\n            type=\"none\", use_carryover=False, content=None, context={}\n        )\n    if isinstance(value, str):\n        return WaldiezChatMessage(\n            type=\"string\", use_carryover=False, content=value, context={}\n        )\n    if isinstance(value, dict):\n        return WaldiezChatMessage.model_validate(value)\n    if isinstance(value, WaldiezChatMessage):\n        return value\n    raise ValueError(f\"Invalid message type: {type(value)}\")\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_nested.WaldiezChatNested.validate_nested_chat","title":"<code>validate_nested_chat() -&gt; Self</code>","text":"<p>Validate the nested chat.</p> <p>Returns:</p> Type Description <code>WaldiezChatNested</code> <p>The validated nested chat.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/chat/chat_nested.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_nested_chat(self) -&gt; Self:\n    \"\"\"Validate the nested chat.\n\n    Returns\n    -------\n    WaldiezChatNested\n        The validated nested chat.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if self.message is not None:\n        self._message_content = self.message.content_body\n        if self.message.type == \"none\":\n            self._message_content = \"\"\n        if self.message.type == \"string\":\n            self._message_content = self.message.content\n        if self.message.type == \"method\":\n            self._message_content = self.message.validate_method(\n                function_name=NESTED_CHAT_MESSAGE,\n                function_args=NESTED_CHAT_ARGS,\n            )\n\n    if self.reply is not None:\n        self._reply_content = self.reply.content_body\n        if self.reply.type == \"none\":\n            self._reply_content = \"\"\n        if self.reply.type == \"string\":\n            self._reply_content = self.reply.content\n        if self.reply.type == \"method\":\n            self._reply_content = self.reply.validate_method(\n                function_name=NESTED_CHAT_REPLY,\n                function_args=NESTED_CHAT_ARGS,\n            )\n    return self\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_summary.WaldiezChatSummary","title":"<code>WaldiezChatSummary</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Llm summary method options.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>Optional[WaldiezChatSummaryMethod]</code> <p>The method to use for the LLM summary. Defaults to \"last_msg\".</p> <code>prompt</code> <code>str</code> <p>The prompt for the LLM summary method.</p> <code>args</code> <code>Optional[Dict[str, Any]]</code> <p>The additional arguments for the LLM summary method, by default None.</p>"},{"location":"models/chat/#waldiez.models.chat.chat_summary.WaldiezChatSummary.serialize_summary_method","title":"<code>serialize_summary_method(value: Any, info: FieldSerializationInfo) -&gt; Any</code>  <code>classmethod</code>","text":"<p>Serialize summary method.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to serialize.</p> required <code>info</code> <code>FieldSerializationInfo</code> <p>The serialization info.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The serialized value.</p> Source code in <code>waldiez/models/chat/chat_summary.py</code> <pre><code>@field_serializer(\"method\")\n@classmethod\ndef serialize_summary_method(\n    cls, value: Any, info: FieldSerializationInfo\n) -&gt; Any:\n    \"\"\"Serialize summary method.\n\n    Parameters\n    ----------\n    value : Any\n        The value to serialize.\n    info : FieldSerializationInfo\n        The serialization info.\n\n    Returns\n    -------\n    Any\n        The serialized value.\n    \"\"\"\n    if info.by_alias is True:\n        if value == \"reflection_with_llm\":\n            return \"reflectionWithLlm\"\n        if value == \"last_msg\":\n            return \"lastMsg\"\n    return value\n</code></pre>"},{"location":"models/chat/#waldiez.models.chat.chat_summary.WaldiezChatSummary.validate_summary_method","title":"<code>validate_summary_method(value: Optional[WaldiezChatSummaryMethod]) -&gt; Optional[WaldiezChatSummaryMethod]</code>  <code>classmethod</code>","text":"<p>Validate the summary method.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[WaldiezChatSummaryMethod]</code> <p>The passed WaldiezChatSummaryMethod</p> required <p>Returns:</p> Type Description <code>Optional[WaldiezChatSummaryMethod]</code> <p>The validated message summary method</p> Source code in <code>waldiez/models/chat/chat_summary.py</code> <pre><code>@field_validator(\"method\", mode=\"before\")\n@classmethod\ndef validate_summary_method(\n    cls, value: Optional[WaldiezChatSummaryMethod]\n) -&gt; Optional[WaldiezChatSummaryMethod]:\n    \"\"\"Validate the summary method.\n\n    Parameters\n    ----------\n    value : Optional[WaldiezChatSummaryMethod]\n        The passed WaldiezChatSummaryMethod\n\n    Returns\n    -------\n    Optional[WaldiezChatSummaryMethod]\n        The validated message summary method\n    \"\"\"\n    if str(value).lower() == \"none\":\n        return None\n    if value == \"lastMsg\":\n        return \"last_msg\"\n    if value == \"reflectionWithLlm\":\n        return \"reflection_with_llm\"\n    return value\n</code></pre>"},{"location":"models/common/","title":"Common","text":"<p>Common utils for all models.</p>"},{"location":"models/common/#waldiez.models.common.WaldiezBase","title":"<code>WaldiezBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model class to inherit from.</p> <p>It contains the default configuration for all models. It also <code>model_dumps</code> by alias by default.</p>"},{"location":"models/common/#waldiez.models.common.WaldiezBase.model_dump","title":"<code>model_dump(**kwargs: Any) -&gt; Dict[str, Any]</code>","text":"<p>Dump the model to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The dictionary representation of the model.</p> Source code in <code>waldiez/models/common/base.py</code> <pre><code>def model_dump(self, **kwargs: Any) -&gt; Dict[str, Any]:\n    \"\"\"Dump the model to a dictionary.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Additional keyword arguments.\n\n    Returns\n    -------\n    Dict[str, Any]\n        The dictionary representation of the model.\n    \"\"\"\n    by_alias = kwargs.pop(\"by_alias\", None)\n    if by_alias is None:\n        by_alias = True\n    if not isinstance(by_alias, bool):\n        by_alias = True\n    return super().model_dump(by_alias=by_alias, **kwargs)\n</code></pre>"},{"location":"models/common/#waldiez.models.common.WaldiezBase.model_dump_json","title":"<code>model_dump_json(**kwargs: Any) -&gt; str</code>","text":"<p>Dump the model to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The JSON string.</p> Source code in <code>waldiez/models/common/base.py</code> <pre><code>def model_dump_json(self, **kwargs: Any) -&gt; str:\n    \"\"\"Dump the model to a JSON string.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Additional keyword arguments.\n\n    Returns\n    -------\n    str\n        The JSON string.\n    \"\"\"\n    by_alias = kwargs.pop(\"by_alias\", None)\n    if by_alias is None:\n        by_alias = True\n    if not isinstance(by_alias, bool):\n        by_alias = True\n    return super().model_dump_json(by_alias=by_alias, **kwargs)\n</code></pre>"},{"location":"models/common/#waldiez.models.common.ag2_version","title":"<code>ag2_version</code>","text":"<p>Get the autogen version.</p>"},{"location":"models/common/#waldiez.models.common.ag2_version.get_autogen_version","title":"<code>get_autogen_version() -&gt; str</code>  <code>cached</code>","text":"<p>Get the autogen version.</p> <p>Returns:</p> Type Description <code>str</code> <p>The autogen version.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If pyautogen is not installed.</p> Source code in <code>waldiez/models/common/ag2_version.py</code> <pre><code>@cache\ndef get_autogen_version() -&gt; str:\n    \"\"\"Get the autogen version.\n\n    Returns\n    -------\n    str\n        The autogen version.\n\n    Raises\n    ------\n    ValueError\n        If pyautogen is not installed.\n    \"\"\"\n    # pylint: disable=import-outside-toplevel\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        try:\n            from autogen.version import __version__ as ag2  # type: ignore\n        except ImportError as error:  # pragma: no cover\n            raise ValueError(\"pyautogen is not installed.\") from error\n    return ag2\n</code></pre>"},{"location":"models/common/#waldiez.models.common.base","title":"<code>base</code>","text":"<p>Base class to inherit from.</p>"},{"location":"models/common/#waldiez.models.common.base.WaldiezBase","title":"<code>WaldiezBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model class to inherit from.</p> <p>It contains the default configuration for all models. It also <code>model_dumps</code> by alias by default.</p>"},{"location":"models/common/#waldiez.models.common.base.WaldiezBase.model_dump","title":"<code>model_dump(**kwargs: Any) -&gt; Dict[str, Any]</code>","text":"<p>Dump the model to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The dictionary representation of the model.</p> Source code in <code>waldiez/models/common/base.py</code> <pre><code>def model_dump(self, **kwargs: Any) -&gt; Dict[str, Any]:\n    \"\"\"Dump the model to a dictionary.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Additional keyword arguments.\n\n    Returns\n    -------\n    Dict[str, Any]\n        The dictionary representation of the model.\n    \"\"\"\n    by_alias = kwargs.pop(\"by_alias\", None)\n    if by_alias is None:\n        by_alias = True\n    if not isinstance(by_alias, bool):\n        by_alias = True\n    return super().model_dump(by_alias=by_alias, **kwargs)\n</code></pre>"},{"location":"models/common/#waldiez.models.common.base.WaldiezBase.model_dump_json","title":"<code>model_dump_json(**kwargs: Any) -&gt; str</code>","text":"<p>Dump the model to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The JSON string.</p> Source code in <code>waldiez/models/common/base.py</code> <pre><code>def model_dump_json(self, **kwargs: Any) -&gt; str:\n    \"\"\"Dump the model to a JSON string.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Additional keyword arguments.\n\n    Returns\n    -------\n    str\n        The JSON string.\n    \"\"\"\n    by_alias = kwargs.pop(\"by_alias\", None)\n    if by_alias is None:\n        by_alias = True\n    if not isinstance(by_alias, bool):\n        by_alias = True\n    return super().model_dump_json(by_alias=by_alias, **kwargs)\n</code></pre>"},{"location":"models/common/#waldiez.models.common.check_function","title":"<code>check_function(code_string: str, function_name: str, function_args: List[str]) -&gt; Tuple[bool, str]</code>","text":"<p>Check the function.</p> <p>Parameters:</p> Name Type Description Default <code>code_string</code> <code>str</code> <p>The code string to check.</p> required <code>function_name</code> <code>str</code> <p>The expected method name.</p> required <code>function_args</code> <code>List[str]</code> <p>The expected method arguments.</p> required <p>Returns:</p> Type Description <code>Tuple[bool, str]</code> <p>If valid, True and the function body (only), no extra lines. If invalid, False and the error message.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def check_function(\n    code_string: str,\n    function_name: str,\n    function_args: List[str],\n) -&gt; Tuple[bool, str]:\n    \"\"\"Check the function.\n\n    Parameters\n    ----------\n    code_string : str\n        The code string to check.\n    function_name : str\n        The expected method name.\n    function_args : List[str]\n        The expected method arguments.\n    Returns\n    -------\n    Tuple[bool, str]\n        If valid, True and the function body (only), no extra lines.\n        If invalid, False and the error message.\n    \"\"\"\n    error, tree = parse_code_string(code_string)\n    if error is not None or tree is None:\n        return False, error or \"Invalid code\"\n    return _validate_function_body(\n        tree,\n        code_string,\n        function_name,\n        function_args,\n    )\n</code></pre>"},{"location":"models/common/#waldiez.models.common.date_utils","title":"<code>date_utils</code>","text":"<p>Date utilities.</p>"},{"location":"models/common/#waldiez.models.common.date_utils.now","title":"<code>now() -&gt; str</code>","text":"<p>Get the current date and time in UTC.</p> <p>Returns:</p> Type Description <code>str</code> <p>The current date and time in UTC.</p> Source code in <code>waldiez/models/common/date_utils.py</code> <pre><code>def now() -&gt; str:\n    \"\"\"Get the current date and time in UTC.\n\n    Returns\n    -------\n    str\n        The current date and time in UTC.\n    \"\"\"\n    return (\n        datetime.now(tz=timezone.utc)\n        .isoformat(timespec=\"milliseconds\")\n        .replace(\"+00:00\", \"Z\")\n    )\n</code></pre>"},{"location":"models/common/#waldiez.models.common.dict_utils","title":"<code>dict_utils</code>","text":"<p>Dictionary related utilities.</p>"},{"location":"models/common/#waldiez.models.common.dict_utils.update_dict","title":"<code>update_dict(original: Dict[str, Any]) -&gt; Dict[str, Any]</code>","text":"<p>Try to determine the type of the dictionary values.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>Dict[str, Any]</code> <p>The original dictionary.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The updated dictionary with values converted to the detected types.</p> Source code in <code>waldiez/models/common/dict_utils.py</code> <pre><code>def update_dict(original: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n\n    Try to determine the type of the dictionary values.\n\n    Parameters\n    ----------\n    original : Dict[str, Any]\n        The original dictionary.\n\n    Returns\n    -------\n    Dict[str, Any]\n        The updated dictionary with values converted to the detected types.\n    \"\"\"\n    new_dict: Dict[str, Any] = {}\n    for key, value in original.items():\n        value_lower = str(value).lower()\n        if value_lower in (\"none\", \"null\"):\n            new_dict[key] = None\n        elif value_lower in (\"true\", \"false\"):\n            new_dict[key] = value_lower == \"true\"\n        elif str(value).isdigit():\n            new_dict[key] = int(value)\n        elif str(value).replace(\".\", \"\").isdigit():\n            try:\n                new_dict[key] = float(value)\n            except ValueError:  # pragma: no cover\n                new_dict[key] = value\n        else:\n            new_dict[key] = value\n    return new_dict\n</code></pre>"},{"location":"models/common/#waldiez.models.common.gather_code_imports","title":"<code>gather_code_imports(code_string: str, is_interop: bool) -&gt; Tuple[List[str], List[str]]</code>","text":"<p>Gather the imports from the code string.</p> <p>Parameters:</p> Name Type Description Default <code>code_string</code> <code>str</code> <p>The code string.</p> required <code>is_interop</code> <code>bool</code> <p>If True, make sure the interoperability import is present.</p> required <p>Returns:</p> Type Description <code>Tuple[List[str], List[str]]</code> <p>The standard library imports and the third party imports.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def gather_code_imports(\n    code_string: str,\n    is_interop: bool,\n) -&gt; Tuple[List[str], List[str]]:\n    \"\"\"Gather the imports from the code string.\n\n    Parameters\n    ----------\n    code_string : str\n        The code string.\n    is_interop : bool\n        If True, make sure the interoperability import is present.\n\n    Returns\n    -------\n    Tuple[List[str], List[str]]\n        The standard library imports and the third party imports.\n    \"\"\"\n    standard_lib_imports: List[str] = []\n    third_party_imports: List[str] = []\n    tree = parso.parse(code_string)  # type: ignore\n    for node in tree.iter_imports():\n        if node.type == \"import_name\":\n            full_import_statement = node.get_code().strip()\n            module_name = (\n                node.get_code().replace(\"import\", \"\").strip().split(\" \")[0]\n            )\n            if not module_name:\n                continue\n            if is_standard_library(module_name):\n                standard_lib_imports.append(full_import_statement)\n            else:\n                third_party_imports.append(full_import_statement)\n        elif node.type == \"import_from\":\n            full_import_statement = node.get_code().strip()\n            module_name = (\n                node.get_code().replace(\"from\", \"\").strip().split(\" \")[0]\n            )\n            if not module_name:\n                continue\n            if is_standard_library(module_name):\n                standard_lib_imports.append(full_import_statement)\n            else:\n                third_party_imports.append(full_import_statement)\n    if is_interop and (\n        \"from autogen.interop import Interoperability\"\n        not in third_party_imports\n    ):\n        third_party_imports.append(\n            \"from autogen.interop import Interoperability\"\n        )\n    # sorted_standard_lib_imports =  # first import x, then from a import b\n    sorted_standard_lib_imports = sorted(\n        [stmt for stmt in standard_lib_imports if stmt.startswith(\"import \")]\n    ) + sorted(\n        [stmt for stmt in standard_lib_imports if stmt.startswith(\"from \")]\n    )\n    sorted_third_party_imports = sorted(\n        [stmt for stmt in third_party_imports if stmt.startswith(\"import \")]\n    ) + sorted(\n        [stmt for stmt in third_party_imports if stmt.startswith(\"from \")]\n    )\n    return sorted_standard_lib_imports, sorted_third_party_imports\n</code></pre>"},{"location":"models/common/#waldiez.models.common.generate_function","title":"<code>generate_function(function_name: str, function_args: List[str], function_types: Tuple[List[str], str], function_body: str, types_as_comments: bool = False) -&gt; str</code>","text":"<p>Generate a function.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>str</code> <p>The function name.</p> required <code>function_args</code> <code>List[str]</code> <p>The function arguments.</p> required <code>function_types</code> <code>Tuple[List[str], str]</code> <p>The function types.</p> required <code>function_body</code> <code>str</code> <p>The function body.</p> required <code>types_as_comments</code> <code>bool</code> <p>Include the type hints as comments (or in the function signature) (default is False).</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The generated function.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def generate_function(\n    function_name: str,\n    function_args: List[str],\n    function_types: Tuple[List[str], str],\n    function_body: str,\n    types_as_comments: bool = False,\n) -&gt; str:\n    \"\"\"Generate a function.\n\n    Parameters\n    ----------\n    function_name : str\n        The function name.\n    function_args : List[str]\n        The function arguments.\n    function_types : Tuple[List[str], str]\n        The function types.\n    function_body : str\n        The function body.\n    types_as_comments : bool, optional\n        Include the type hints as comments (or in the function signature)\n        (default is False).\n    Returns\n    -------\n    str\n        The generated function.\n    \"\"\"\n    if len(function_name) &gt; MAX_VAR_NAME_LENGTH:\n        function_name = function_name[:MAX_VAR_NAME_LENGTH]\n    function_string = f\"def {function_name}(\"\n    if not function_args:\n        function_string += \")\"\n    else:\n        function_string += \"\\n\"\n        for arg, arg_type in zip(function_args, function_types[0]):\n            if types_as_comments:\n                function_string += f\"    {arg},  # type: {arg_type}\" + \"\\n\"\n            else:\n                function_string += f\"    {arg}: {arg_type},\" + \"\\n\"\n        function_string += \")\"\n    if types_as_comments:\n        function_string += \":\\n\"\n        function_string += \"    # type: (...) -&gt; \" + function_types[1]\n    else:\n        function_string += \" -&gt; \" + function_types[1] + \":\"\n    function_string += \"\\n\" if not function_body.startswith(\"\\n\") else \"\"\n    function_string += f\"{function_body}\"\n    if not function_string.endswith(\"\\n\"):\n        function_string += \"\\n\"\n    return function_string\n</code></pre>"},{"location":"models/common/#waldiez.models.common.get_autogen_version","title":"<code>get_autogen_version() -&gt; str</code>  <code>cached</code>","text":"<p>Get the autogen version.</p> <p>Returns:</p> Type Description <code>str</code> <p>The autogen version.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If pyautogen is not installed.</p> Source code in <code>waldiez/models/common/ag2_version.py</code> <pre><code>@cache\ndef get_autogen_version() -&gt; str:\n    \"\"\"Get the autogen version.\n\n    Returns\n    -------\n    str\n        The autogen version.\n\n    Raises\n    ------\n    ValueError\n        If pyautogen is not installed.\n    \"\"\"\n    # pylint: disable=import-outside-toplevel\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        try:\n            from autogen.version import __version__ as ag2  # type: ignore\n        except ImportError as error:  # pragma: no cover\n            raise ValueError(\"pyautogen is not installed.\") from error\n    return ag2\n</code></pre>"},{"location":"models/common/#waldiez.models.common.get_function","title":"<code>get_function(code_string: str, function_name: str) -&gt; str</code>","text":"<p>Get the function signature and body.</p> <p>Parameters:</p> Name Type Description Default <code>code_string</code> <code>str</code> <p>The code string.</p> required <code>function_name</code> <code>str</code> <p>The function name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The function signature and body.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def get_function(\n    code_string: str,\n    function_name: str,\n) -&gt; str:\n    \"\"\"Get the function signature and body.\n\n    Parameters\n    ----------\n    code_string : str\n        The code string.\n    function_name : str\n        The function name.\n\n    Returns\n    -------\n    str\n        The function signature and body.\n    \"\"\"\n    tree = parso.parse(code_string)  # type: ignore\n    for node in tree.iter_funcdefs():\n        if node.name.value == function_name:\n            return node.get_code()\n    return \"\"\n</code></pre>"},{"location":"models/common/#waldiez.models.common.method_utils","title":"<code>method_utils</code>","text":"<p>Function related utilities.</p>"},{"location":"models/common/#waldiez.models.common.method_utils.check_function","title":"<code>check_function(code_string: str, function_name: str, function_args: List[str]) -&gt; Tuple[bool, str]</code>","text":"<p>Check the function.</p> <p>Parameters:</p> Name Type Description Default <code>code_string</code> <code>str</code> <p>The code string to check.</p> required <code>function_name</code> <code>str</code> <p>The expected method name.</p> required <code>function_args</code> <code>List[str]</code> <p>The expected method arguments.</p> required <p>Returns:</p> Type Description <code>Tuple[bool, str]</code> <p>If valid, True and the function body (only), no extra lines. If invalid, False and the error message.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def check_function(\n    code_string: str,\n    function_name: str,\n    function_args: List[str],\n) -&gt; Tuple[bool, str]:\n    \"\"\"Check the function.\n\n    Parameters\n    ----------\n    code_string : str\n        The code string to check.\n    function_name : str\n        The expected method name.\n    function_args : List[str]\n        The expected method arguments.\n    Returns\n    -------\n    Tuple[bool, str]\n        If valid, True and the function body (only), no extra lines.\n        If invalid, False and the error message.\n    \"\"\"\n    error, tree = parse_code_string(code_string)\n    if error is not None or tree is None:\n        return False, error or \"Invalid code\"\n    return _validate_function_body(\n        tree,\n        code_string,\n        function_name,\n        function_args,\n    )\n</code></pre>"},{"location":"models/common/#waldiez.models.common.method_utils.gather_code_imports","title":"<code>gather_code_imports(code_string: str, is_interop: bool) -&gt; Tuple[List[str], List[str]]</code>","text":"<p>Gather the imports from the code string.</p> <p>Parameters:</p> Name Type Description Default <code>code_string</code> <code>str</code> <p>The code string.</p> required <code>is_interop</code> <code>bool</code> <p>If True, make sure the interoperability import is present.</p> required <p>Returns:</p> Type Description <code>Tuple[List[str], List[str]]</code> <p>The standard library imports and the third party imports.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def gather_code_imports(\n    code_string: str,\n    is_interop: bool,\n) -&gt; Tuple[List[str], List[str]]:\n    \"\"\"Gather the imports from the code string.\n\n    Parameters\n    ----------\n    code_string : str\n        The code string.\n    is_interop : bool\n        If True, make sure the interoperability import is present.\n\n    Returns\n    -------\n    Tuple[List[str], List[str]]\n        The standard library imports and the third party imports.\n    \"\"\"\n    standard_lib_imports: List[str] = []\n    third_party_imports: List[str] = []\n    tree = parso.parse(code_string)  # type: ignore\n    for node in tree.iter_imports():\n        if node.type == \"import_name\":\n            full_import_statement = node.get_code().strip()\n            module_name = (\n                node.get_code().replace(\"import\", \"\").strip().split(\" \")[0]\n            )\n            if not module_name:\n                continue\n            if is_standard_library(module_name):\n                standard_lib_imports.append(full_import_statement)\n            else:\n                third_party_imports.append(full_import_statement)\n        elif node.type == \"import_from\":\n            full_import_statement = node.get_code().strip()\n            module_name = (\n                node.get_code().replace(\"from\", \"\").strip().split(\" \")[0]\n            )\n            if not module_name:\n                continue\n            if is_standard_library(module_name):\n                standard_lib_imports.append(full_import_statement)\n            else:\n                third_party_imports.append(full_import_statement)\n    if is_interop and (\n        \"from autogen.interop import Interoperability\"\n        not in third_party_imports\n    ):\n        third_party_imports.append(\n            \"from autogen.interop import Interoperability\"\n        )\n    # sorted_standard_lib_imports =  # first import x, then from a import b\n    sorted_standard_lib_imports = sorted(\n        [stmt for stmt in standard_lib_imports if stmt.startswith(\"import \")]\n    ) + sorted(\n        [stmt for stmt in standard_lib_imports if stmt.startswith(\"from \")]\n    )\n    sorted_third_party_imports = sorted(\n        [stmt for stmt in third_party_imports if stmt.startswith(\"import \")]\n    ) + sorted(\n        [stmt for stmt in third_party_imports if stmt.startswith(\"from \")]\n    )\n    return sorted_standard_lib_imports, sorted_third_party_imports\n</code></pre>"},{"location":"models/common/#waldiez.models.common.method_utils.generate_function","title":"<code>generate_function(function_name: str, function_args: List[str], function_types: Tuple[List[str], str], function_body: str, types_as_comments: bool = False) -&gt; str</code>","text":"<p>Generate a function.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>str</code> <p>The function name.</p> required <code>function_args</code> <code>List[str]</code> <p>The function arguments.</p> required <code>function_types</code> <code>Tuple[List[str], str]</code> <p>The function types.</p> required <code>function_body</code> <code>str</code> <p>The function body.</p> required <code>types_as_comments</code> <code>bool</code> <p>Include the type hints as comments (or in the function signature) (default is False).</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The generated function.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def generate_function(\n    function_name: str,\n    function_args: List[str],\n    function_types: Tuple[List[str], str],\n    function_body: str,\n    types_as_comments: bool = False,\n) -&gt; str:\n    \"\"\"Generate a function.\n\n    Parameters\n    ----------\n    function_name : str\n        The function name.\n    function_args : List[str]\n        The function arguments.\n    function_types : Tuple[List[str], str]\n        The function types.\n    function_body : str\n        The function body.\n    types_as_comments : bool, optional\n        Include the type hints as comments (or in the function signature)\n        (default is False).\n    Returns\n    -------\n    str\n        The generated function.\n    \"\"\"\n    if len(function_name) &gt; MAX_VAR_NAME_LENGTH:\n        function_name = function_name[:MAX_VAR_NAME_LENGTH]\n    function_string = f\"def {function_name}(\"\n    if not function_args:\n        function_string += \")\"\n    else:\n        function_string += \"\\n\"\n        for arg, arg_type in zip(function_args, function_types[0]):\n            if types_as_comments:\n                function_string += f\"    {arg},  # type: {arg_type}\" + \"\\n\"\n            else:\n                function_string += f\"    {arg}: {arg_type},\" + \"\\n\"\n        function_string += \")\"\n    if types_as_comments:\n        function_string += \":\\n\"\n        function_string += \"    # type: (...) -&gt; \" + function_types[1]\n    else:\n        function_string += \" -&gt; \" + function_types[1] + \":\"\n    function_string += \"\\n\" if not function_body.startswith(\"\\n\") else \"\"\n    function_string += f\"{function_body}\"\n    if not function_string.endswith(\"\\n\"):\n        function_string += \"\\n\"\n    return function_string\n</code></pre>"},{"location":"models/common/#waldiez.models.common.method_utils.get_function","title":"<code>get_function(code_string: str, function_name: str) -&gt; str</code>","text":"<p>Get the function signature and body.</p> <p>Parameters:</p> Name Type Description Default <code>code_string</code> <code>str</code> <p>The code string.</p> required <code>function_name</code> <code>str</code> <p>The function name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The function signature and body.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def get_function(\n    code_string: str,\n    function_name: str,\n) -&gt; str:\n    \"\"\"Get the function signature and body.\n\n    Parameters\n    ----------\n    code_string : str\n        The code string.\n    function_name : str\n        The function name.\n\n    Returns\n    -------\n    str\n        The function signature and body.\n    \"\"\"\n    tree = parso.parse(code_string)  # type: ignore\n    for node in tree.iter_funcdefs():\n        if node.name.value == function_name:\n            return node.get_code()\n    return \"\"\n</code></pre>"},{"location":"models/common/#waldiez.models.common.method_utils.is_standard_library","title":"<code>is_standard_library(module_name: str) -&gt; bool</code>","text":"<p>Check if the module is part of the standard library.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>The module name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the module is part of the standard library.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def is_standard_library(module_name: str) -&gt; bool:\n    \"\"\"Check if the module is part of the standard library.\n\n    Parameters\n    ----------\n    module_name : str\n        The module name.\n\n    Returns\n    -------\n    bool\n        True if the module is part of the standard library.\n    \"\"\"\n    if module_name in sys.builtin_module_names:\n        return True\n    try:\n        spec = importlib.util.find_spec(module_name)\n    except BaseException:  # pylint: disable=broad-except\n        return False\n    if spec is None or not spec.origin:\n        return False\n    if \"site-packages\" in spec.origin:\n        return False\n    if spec.origin.startswith(sys.prefix) or spec.origin == \"frozen\":\n        return True\n    stdlib_path = sysconfig.get_path(\"stdlib\")\n    return spec.origin.startswith(stdlib_path)\n</code></pre>"},{"location":"models/common/#waldiez.models.common.method_utils.parse_code_string","title":"<code>parse_code_string(code_string: str) -&gt; Tuple[Optional[str], Optional[ast.Module]]</code>","text":"<p>Parse the code string.</p> <p>Parameters:</p> Name Type Description Default <code>code_string</code> <code>str</code> <p>The code string.</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[Module]]</code> <p>If valid, None and the ast module. If invalid, the error message and None.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def parse_code_string(\n    code_string: str,\n) -&gt; Tuple[Optional[str], Optional[ast.Module]]:\n    \"\"\"Parse the code string.\n\n    Parameters\n    ----------\n    code_string : str\n        The code string.\n\n    Returns\n    -------\n    Tuple[Optional[str], Optional[ast.Module]]\n        If valid, None and the ast module.\n        If invalid, the error message and None.\n    \"\"\"\n    # pylint: disable=broad-except\n    try:\n        tree = ast.parse(code_string)\n    except SyntaxError as e:\n        return f\"SyntaxError: {e}, in \" + \"\\n\" + f\"{code_string}\", None\n    except BaseException as e:  # pragma: no cover\n        return f\"Invalid code: {e}, in \" + \"\\n\" + f\"{code_string}\", None\n    return None, tree\n</code></pre>"},{"location":"models/common/#waldiez.models.common.now","title":"<code>now() -&gt; str</code>","text":"<p>Get the current date and time in UTC.</p> <p>Returns:</p> Type Description <code>str</code> <p>The current date and time in UTC.</p> Source code in <code>waldiez/models/common/date_utils.py</code> <pre><code>def now() -&gt; str:\n    \"\"\"Get the current date and time in UTC.\n\n    Returns\n    -------\n    str\n        The current date and time in UTC.\n    \"\"\"\n    return (\n        datetime.now(tz=timezone.utc)\n        .isoformat(timespec=\"milliseconds\")\n        .replace(\"+00:00\", \"Z\")\n    )\n</code></pre>"},{"location":"models/common/#waldiez.models.common.parse_code_string","title":"<code>parse_code_string(code_string: str) -&gt; Tuple[Optional[str], Optional[ast.Module]]</code>","text":"<p>Parse the code string.</p> <p>Parameters:</p> Name Type Description Default <code>code_string</code> <code>str</code> <p>The code string.</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[Module]]</code> <p>If valid, None and the ast module. If invalid, the error message and None.</p> Source code in <code>waldiez/models/common/method_utils.py</code> <pre><code>def parse_code_string(\n    code_string: str,\n) -&gt; Tuple[Optional[str], Optional[ast.Module]]:\n    \"\"\"Parse the code string.\n\n    Parameters\n    ----------\n    code_string : str\n        The code string.\n\n    Returns\n    -------\n    Tuple[Optional[str], Optional[ast.Module]]\n        If valid, None and the ast module.\n        If invalid, the error message and None.\n    \"\"\"\n    # pylint: disable=broad-except\n    try:\n        tree = ast.parse(code_string)\n    except SyntaxError as e:\n        return f\"SyntaxError: {e}, in \" + \"\\n\" + f\"{code_string}\", None\n    except BaseException as e:  # pragma: no cover\n        return f\"Invalid code: {e}, in \" + \"\\n\" + f\"{code_string}\", None\n    return None, tree\n</code></pre>"},{"location":"models/common/#waldiez.models.common.update_dict","title":"<code>update_dict(original: Dict[str, Any]) -&gt; Dict[str, Any]</code>","text":"<p>Try to determine the type of the dictionary values.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>Dict[str, Any]</code> <p>The original dictionary.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The updated dictionary with values converted to the detected types.</p> Source code in <code>waldiez/models/common/dict_utils.py</code> <pre><code>def update_dict(original: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n\n    Try to determine the type of the dictionary values.\n\n    Parameters\n    ----------\n    original : Dict[str, Any]\n        The original dictionary.\n\n    Returns\n    -------\n    Dict[str, Any]\n        The updated dictionary with values converted to the detected types.\n    \"\"\"\n    new_dict: Dict[str, Any] = {}\n    for key, value in original.items():\n        value_lower = str(value).lower()\n        if value_lower in (\"none\", \"null\"):\n            new_dict[key] = None\n        elif value_lower in (\"true\", \"false\"):\n            new_dict[key] = value_lower == \"true\"\n        elif str(value).isdigit():\n            new_dict[key] = int(value)\n        elif str(value).replace(\".\", \"\").isdigit():\n            try:\n                new_dict[key] = float(value)\n            except ValueError:  # pragma: no cover\n                new_dict[key] = value\n        else:\n            new_dict[key] = value\n    return new_dict\n</code></pre>"},{"location":"models/flow/","title":"Flow","text":"<p>Waldiez flow model.</p> <p>Waldiez flow data.</p>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow","title":"<code>WaldiezFlow</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Flow data class.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the flow.</p> <code>type</code> <code>(Literal['flow'], optional)</code> <p>The type of the \"node\" in a graph: \"flow\".</p> <code>name</code> <code>str</code> <p>The name of the flow.</p> <code>description</code> <code>str</code> <p>The description of the flow.</p> <code>tags</code> <code>List[str]</code> <p>The tags of the flow.</p> <code>requirements</code> <code>List[str]</code> <p>The requirements of the flow.</p> <code>storage_id</code> <code>str</code> <p>The storage ID of the flow (ignored, UI related).</p> <code>created_at</code> <code>str</code> <p>The date and time when the flow was created.</p> <code>updated_at</code> <code>str</code> <p>The date and time when the flow was last updated.</p> <code>data</code> <code>WaldiezFlowData</code> <p>The data of the flow. See <code>WaldiezFlowData</code>.</p>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.cache_seed","title":"<code>cache_seed: Optional[int]</code>  <code>property</code>","text":"<p>Check if the flow has caching disabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the flow has caching disabled, False otherwise.</p>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.get_agent_by_id","title":"<code>get_agent_by_id(agent_id: str) -&gt; WaldiezAgent</code>","text":"<p>Get the agent by ID.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>The ID of the agent.</p> required <p>Returns:</p> Type Description <code>WaldiezAgent</code> <p>The agent.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the agent with the given ID is not found.</p> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>def get_agent_by_id(self, agent_id: str) -&gt; WaldiezAgent:\n    \"\"\"Get the agent by ID.\n\n    Parameters\n    ----------\n    agent_id : str\n        The ID of the agent.\n\n    Returns\n    -------\n    WaldiezAgent\n        The agent.\n\n    Raises\n    ------\n    ValueError\n        If the agent with the given ID is not found.\n    \"\"\"\n    for agent in self.data.agents.members:\n        if agent.id == agent_id:\n            return agent\n    raise ValueError(f\"Agent with ID {agent_id} not found.\")\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.get_agent_connections","title":"<code>get_agent_connections(agent_id: str, all_chats: bool = True) -&gt; List[str]</code>","text":"<p>Get the agent connections.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>The ID of the agent.</p> required <code>all_chats</code> <code>bool</code> <p>If True, get the connections from all the chats, otherwise get the connections from the ordered flow (main chat flow).</p> <code>True</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of agent ids that the agent with the given ID connects to.</p> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>def get_agent_connections(\n    self, agent_id: str, all_chats: bool = True\n) -&gt; List[str]:\n    \"\"\"Get the agent connections.\n\n    Parameters\n    ----------\n    agent_id : str\n        The ID of the agent.\n    all_chats : bool, optional\n        If True, get the connections from all the chats, otherwise\n        get the connections from the ordered flow (main chat flow).\n\n    Returns\n    -------\n    List[str]\n        The list of agent ids that the agent with the given ID connects to.\n    \"\"\"\n    connections: List[str] = []\n    if all_chats:\n        for chat in self.data.chats:\n            if chat.source == agent_id:\n                connections.append(chat.target)\n            if chat.target == agent_id:\n                connections.append(chat.source)\n    else:\n        for _, source, target in self.ordered_flow:\n            if source.id == agent_id:\n                connections.append(target.id)\n            if target.id == agent_id:\n                connections.append(source.id)\n    return connections\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.get_group_chat_members","title":"<code>get_group_chat_members(group_manager_id: str) -&gt; List[WaldiezAgent]</code>","text":"<p>Get the group chat members.</p> <p>Parameters:</p> Name Type Description Default <code>group_manager_id</code> <code>str</code> <p>The ID of the group manager.</p> required <p>Returns:</p> Type Description <code>List[WaldiezAgent]</code> <p>The list of group chat</p> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>def get_group_chat_members(\n    self, group_manager_id: str\n) -&gt; List[WaldiezAgent]:\n    \"\"\"Get the group chat members.\n\n    Parameters\n    ----------\n    group_manager_id : str\n        The ID of the group manager.\n\n    Returns\n    -------\n    List[WaldiezAgent]\n        The list of group chat\n    \"\"\"\n    agent = self.get_agent_by_id(group_manager_id)\n    if agent.agent_type != \"manager\":\n        return []\n    connections = self.get_agent_connections(\n        group_manager_id,\n        all_chats=True,\n    )\n    return [self.get_agent_by_id(member_id) for member_id in connections]\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.get_initial_swarm_agent","title":"<code>get_initial_swarm_agent() -&gt; Optional[WaldiezAgent]</code>","text":"<p>Get the initial swarm agent.</p> <p>Returns:</p> Type Description <code>Optional[WaldiezAgent]</code> <p>The initial swarm agent if found, None otherwise.</p> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>def get_initial_swarm_agent(self) -&gt; Optional[WaldiezAgent]:\n    \"\"\"Get the initial swarm agent.\n\n    Returns\n    -------\n    Optional[WaldiezAgent]\n        The initial swarm agent if found, None otherwise.\n    \"\"\"\n    fallback_agent = None\n    for chat in self.data.chats:\n        source_agent = self.get_agent_by_id(chat.source)\n        target_agent = self.get_agent_by_id(chat.target)\n        if (\n            target_agent.agent_type == \"swarm\"\n            and source_agent.agent_type != \"swarm\"\n        ):\n            return target_agent\n        if (\n            source_agent.agent_type == \"swarm\"\n            and target_agent.agent_type == \"swarm\"\n        ):\n            fallback_agent = source_agent\n            break\n    for swarm_agent in self.data.agents.swarm_agents:\n        if swarm_agent.is_initial:\n            return swarm_agent\n    return fallback_agent\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.get_swarm_chat_members","title":"<code>get_swarm_chat_members(initial_agent: WaldiezAgent) -&gt; Tuple[List[WaldiezAgent], Optional[WaldiezAgent]]</code>","text":"<p>Get the swarm chat members.</p> <p>Parameters:</p> Name Type Description Default <code>initial_agent</code> <code>WaldiezAgent</code> <p>The initial agent.</p> required <p>Returns:</p> Type Description <code>Tuple[List[WaldiezAgent], Optional[WaldiezAgent]]</code> <p>The list of swarm chat members and the user agent if any.</p> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>def get_swarm_chat_members(\n    self,\n    initial_agent: WaldiezAgent,\n) -&gt; Tuple[List[WaldiezAgent], Optional[WaldiezAgent]]:\n    \"\"\"Get the swarm chat members.\n\n    Parameters\n    ----------\n    initial_agent : WaldiezAgent\n        The initial agent.\n\n    Returns\n    -------\n    Tuple[List[WaldiezAgent], Optional[WaldiezAgent]]\n        The list of swarm chat members and the user agent if any.\n    \"\"\"\n    if initial_agent.agent_type != \"swarm\":\n        return [], None\n    members: List[WaldiezAgent] = [initial_agent]\n    user_agent: Optional[WaldiezAgent] = None\n    visited_agents = set()\n    visited_agents.add(initial_agent.id)\n    connections = self.get_agent_connections(\n        initial_agent.id,\n        all_chats=True,\n    )\n    while connections:\n        agent_id = connections.pop()\n        if agent_id in visited_agents:\n            continue\n        agent = self.get_agent_by_id(agent_id)\n        visited_agents.add(agent_id)\n        if agent.agent_type == \"swarm\":\n            members.append(agent)\n            connections.extend(\n                self.get_agent_connections(agent_id, all_chats=True)\n            )\n        if agent.agent_type in [\"user\", \"rag_user\"] and not user_agent:\n            user_agent = agent\n    return members, user_agent\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.is_async","title":"<code>is_async: bool</code>  <code>property</code>","text":"<p>Check if the flow is asynchronous.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the flow is asynchronous, False otherwise.</p>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.is_single_agent_mode","title":"<code>is_single_agent_mode: bool</code>  <code>property</code>","text":"<p>Check if the flow is in single agent mode.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the flow is in single agent mode, False otherwise.</p>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.is_swarm_flow","title":"<code>is_swarm_flow: bool</code>  <code>property</code>","text":"<p>Check if the flow is a swarm flow.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the flow is a swarm flow, False otherwise.</p>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.ordered_flow","title":"<code>ordered_flow: List[Tuple[WaldiezChat, WaldiezAgent, WaldiezAgent]]</code>  <code>property</code>","text":"<p>Get the ordered flow.</p>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.validate_flow","title":"<code>validate_flow() -&gt; Self</code>","text":"<p>Flow validation.</p> <ul> <li>unique node ids</li> <li>there are at least two agents     - (or a single agent but not a group manager or a swarm agent)</li> <li>all the agents connect to at least one other agent</li> <li>all the linked agent skills are found in the flow</li> <li>all the linked agent models are found in the flow</li> <li>all the managers have at least one member in the chat group</li> <li>the ordered flow (chats with position &gt;=0) is not empty</li> <li>all agents' code execution config functions exist in the flow skills</li> <li>if swarm flow, there is at least one swarm agent</li> <li>if swarm flow, there is an initial swarm agent</li> </ul> <p>Returns:</p> Type Description <code>WaldiezFlow</code> <p>The validated flow.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the ordered flow is empty. If the model IDs are not unique. If the skill IDs are not unique. If the agents do not connect to any other node. If the manager's group chat has no members.</p> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_flow(self) -&gt; Self:\n    \"\"\"Flow validation.\n\n    - unique node ids\n    - there are at least two agents\n        - (or a single agent but not a group manager or a swarm agent)\n    - all the agents connect to at least one other agent\n    - all the linked agent skills are found in the flow\n    - all the linked agent models are found in the flow\n    - all the managers have at least one member in the chat group\n    - the ordered flow (chats with position &gt;=0) is not empty\n    - all agents' code execution config functions exist in the flow skills\n    - if swarm flow, there is at least one swarm agent\n    - if swarm flow, there is an initial swarm agent\n\n    Returns\n    -------\n    WaldiezFlow\n        The validated flow.\n\n    Raises\n    ------\n    ValueError\n        If the ordered flow is empty.\n        If the model IDs are not unique.\n        If the skill IDs are not unique.\n        If the agents do not connect to any other node.\n        If the manager's group chat has no members.\n    \"\"\"\n    all_members = list(self.data.agents.members)\n    if len(all_members) == 1:\n        return self.validate_single_agent_mode(all_members[0])\n    if not self.ordered_flow:\n        raise ValueError(\"The ordered flow is empty.\")\n    model_ids = self.validate_flow_models()\n    skills_ids = self.validate_flow_skills()\n    self.data.agents.validate_flow(model_ids, skills_ids)\n    self._validate_agent_connections()\n    if self.is_swarm_flow:\n        for swarm_agent in self.data.agents.swarm_agents:\n            check_handoff_to_nested_chat(\n                swarm_agent,\n                all_agents=list(self.data.agents.members),\n                all_chats=self.data.chats,\n            )\n    return self\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.validate_flow_models","title":"<code>validate_flow_models() -&gt; List[str]</code>","text":"<p>Validate the flow models.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of model IDs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the model IDs are not unique.</p> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>def validate_flow_models(self) -&gt; List[str]:\n    \"\"\"Validate the flow models.\n\n    Returns\n    -------\n    List[str]\n        The list of model IDs.\n\n    Raises\n    ------\n    ValueError\n        If the model IDs are not unique.\n    \"\"\"\n    model_ids = [model.id for model in self.data.models]\n    if len(model_ids) != len(set(model_ids)):\n        raise ValueError(\"Model IDs must be unique.\")\n    return model_ids\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.validate_flow_skills","title":"<code>validate_flow_skills() -&gt; List[str]</code>","text":"<p>Validate the flow skills.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of skill IDs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the skill IDs are not unique.</p> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>def validate_flow_skills(self) -&gt; List[str]:\n    \"\"\"Validate the flow skills.\n\n    Returns\n    -------\n    List[str]\n        The list of skill IDs.\n\n    Raises\n    ------\n    ValueError\n        If the skill IDs are not unique.\n    \"\"\"\n    skill_ids = [skill.id for skill in self.data.skills]\n    if len(skill_ids) != len(set(skill_ids)):\n        raise ValueError(\"Skill IDs must be unique.\")\n    return skill_ids\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow.WaldiezFlow.validate_single_agent_mode","title":"<code>validate_single_agent_mode(member: WaldiezAgent) -&gt; Self</code>","text":"<p>Flow validation for single agent mode.</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>WaldiezAgent</code> <p>The only agent in the flow</p> required <p>Returns:</p> Type Description <code>WaldiezFlow</code> <p>The validated flow.</p> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If the only agent is a group manager or a swarm agent.</li> <li>If the model IDs are not unique.</li> <li>If the skill IDs are not unique.</li> </ul> Source code in <code>waldiez/models/flow/flow.py</code> <pre><code>def validate_single_agent_mode(self, member: WaldiezAgent) -&gt; Self:\n    \"\"\"Flow validation for single agent mode.\n\n    Parameters\n    ----------\n    member : WaldiezAgent\n        The only agent in the flow\n    Returns\n    -------\n    WaldiezFlow\n        The validated flow.\n\n    Raises\n    ------\n    ValueError\n        - If the only agent is a group manager or a swarm agent.\n        - If the model IDs are not unique.\n        - If the skill IDs are not unique.\n    \"\"\"\n    if member.agent_type in [\"manager\", \"swarm\"]:\n        raise ValueError(\n            \"In single agent mode, \"\n            \"the agent must not be a group manager or a swarm agent.\"\n        )\n    model_ids = self.validate_flow_models()\n    skills_ids = self.validate_flow_skills()\n    self.data.agents.validate_flow(model_ids, skills_ids)\n    self._single_agent_mode = True\n    return self\n</code></pre>"},{"location":"models/flow/#waldiez.models.flow.flow_data.WaldiezFlowData","title":"<code>WaldiezFlowData</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Flow data class.</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>List[Dict[str, Any]]</code> <p>The nodes of the flow. We ignore this (UI-related)</p> <code>edges</code> <code>List[Dict[str, Any]]</code> <p>The edges of the flow. We ignore this (UI-related)</p> <code>viewport</code> <code>Dict[str, Any]</code> <p>The viewport of the flow. We ignore this (UI-related)</p> <code>agents</code> <code>WaldiezAgents</code> <p>The agents of the flow: users: List[WaldiezUserProxy] assistants: List[WaldiezAssistant] managers: List[WaldiezGroupManager] rag_users : List[WaldiezRagUser] See <code>WaldiezAgents</code> for more info.</p> <code>models</code> <code>List[WaldiezModel]</code> <p>The models of the flow. See <code>WaldiezModel</code>.</p> <code>skills</code> <code>List[WaldiezSkill]</code> <p>The skills of the flow. See <code>WaldiezSkill</code>.</p> <code>chats</code> <code>List[WaldiezChat]</code> <p>The chats of the flow. See <code>WaldiezChat</code>.</p> <code>is_async</code> <code>bool</code> <p>Whether the flow is asynchronous or not.</p> <code>cache_seed</code> <code>Optional[int]</code> <p>The seed for the cache. If None, the seed is not set. Default is 41.</p>"},{"location":"models/flow/#waldiez.models.flow.flow_data.WaldiezFlowData.validate_flow_chats","title":"<code>validate_flow_chats() -&gt; Self</code>","text":"<p>Validate the flow chats.</p> <p>Returns:</p> Type Description <code>WaldiezFlowData</code> <p>The flow data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is a chat with a prerequisite that does not exist.</p> Source code in <code>waldiez/models/flow/flow_data.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_flow_chats(self) -&gt; Self:\n    \"\"\"Validate the flow chats.\n\n    Returns\n    -------\n    WaldiezFlowData\n        The flow data.\n\n    Raises\n    ------\n    ValueError\n        If there is a chat with a prerequisite that does not exist.\n    \"\"\"\n    self.chats = sorted(self.chats, key=lambda x: x.order)\n    # in async, ag2 uses the \"chat_id\" field (and it must be an int):\n    # ```\n    #    prerequisites = []\n    #    for chat_info in chat_queue:\n    #        if \"chat_id\" not in chat_info:\n    #            raise ValueError(\n    #               \"Each chat must have a unique id for \"\n    #               \"async multi-chat execution.\"\n    #            )\n    #     chat_id = chat_info[\"chat_id\"]\n    #     pre_chats = chat_info.get(\"prerequisites\", [])\n    #     for pre_chat_id in pre_chats:\n    #         if not isinstance(pre_chat_id, int):\n    #             raise ValueError(\"Prerequisite chat id is not int.\")\n    #         prerequisites.append((chat_id, pre_chat_id))\n    #    return prerequisites\n    # ```\n    id_to_chat_id: Dict[str, int] = {}\n    for index, chat in enumerate(self.chats):\n        id_to_chat_id[chat.id] = index\n        chat.set_chat_id(index)\n    if not self.is_async:\n        return self\n    # also update the chat prerequisites (if async)\n    #  we have ids(str), not chat_ids(int)\n    for chat in self.chats:\n        chat_prerequisites = []\n        for chat_id in chat.data.prerequisites:\n            if chat_id not in id_to_chat_id:  # pragma: no cover\n                raise ValueError(\n                    f\"Chat with id {chat_id} not found in the flow.\"\n                )\n            chat_prerequisites.append(id_to_chat_id[chat_id])\n        chat.set_prerequisites(chat_prerequisites)\n    return self\n</code></pre>"},{"location":"models/model/","title":"Model","text":"<p>Waldiez model model.</p> <p>Waldiez Model Data.</p>"},{"location":"models/model/#waldiez.models.model.model.WaldiezModel","title":"<code>WaldiezModel</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Model class.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the model.</p> <code>name</code> <code>str</code> <p>The name of the model.</p> <code>description</code> <code>str</code> <p>The description of the model.</p> <code>tags</code> <code>List[str]</code> <p>The tags of the model.</p> <code>requirements</code> <code>List[str]</code> <p>The requirements of the model.</p> <code>created_at</code> <code>str</code> <p>The date and time when the model was created.</p> <code>updated_at</code> <code>str</code> <p>The date and time when the model was last updated.</p> <code>data</code> <code>WaldiezModelData</code> <p>The data of the model. See <code>waldiez.models.model.WaldiezModelData</code> for more information.</p>"},{"location":"models/model/#waldiez.models.model.model.WaldiezModel.api_key","title":"<code>api_key: str</code>  <code>property</code>","text":"<p>Get the model's api key.</p> <p>Either from the model's data or from the environment variables:</p> <pre><code>- openai: 'OPENAI_API_KEY',\n- azure: 'AZURE_API_KEY',\n- deepseek: 'DEEPSEEK_API_KEY',\n- google: 'GOOGLE_GEMINI_API_KEY',\n- anthropic: 'ANTHROPIC_API_KEY',\n- mistral: 'MISTRAL_API_KEY',\n- groq: 'GROQ_API_KEY',\n- together: 'TOGETHER_API_KEY',\n- nim: 'NIM_API_KEY',\n- cohere: 'COHERE_API_KEY',\n- other: 'OPENAI_API_KEY'\n</code></pre>"},{"location":"models/model/#waldiez.models.model.model.WaldiezModel.api_key_env_key","title":"<code>api_key_env_key: str</code>  <code>property</code>","text":"<p>Get the model's api key environment key to check.</p> <ul> <li>openai: 'OPENAI_API_KEY',</li> <li>azure: 'AZURE_API_KEY',</li> <li>deepseek: 'DEEPSEEK_API_KEY',</li> <li>google: 'GOOGLE_GEMINI_API_KEY',</li> <li>anthropic: 'ANTHROPIC_API_KEY',</li> <li>mistral: 'MISTRAL_API_KEY',</li> <li>groq: 'GROQ_API_KEY',</li> <li>together: 'TOGETHER_API_KEY',</li> <li>nim: 'NIM_API_KEY',</li> <li>cohere: 'COHERE_API_KEY',</li> <li>other: 'OPENAI_API_KEY'</li> </ul>"},{"location":"models/model/#waldiez.models.model.model.WaldiezModel.get_llm_config","title":"<code>get_llm_config(skip_price: bool = False) -&gt; Dict[str, Any]</code>","text":"<p>Get the model's llm config.</p> <p>Parameters:</p> Name Type Description Default <code>skip_price</code> <code>bool</code> <p>Whether to skip the price, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The model's llm config dictionary.</p> Source code in <code>waldiez/models/model/model.py</code> <pre><code>def get_llm_config(self, skip_price: bool = False) -&gt; Dict[str, Any]:\n    \"\"\"Get the model's llm config.\n\n    Parameters\n    ----------\n    skip_price : bool, optional\n        Whether to skip the price, by default False\n\n    Returns\n    -------\n    Dict[str, Any]\n        The model's llm config dictionary.\n    \"\"\"\n    _llm_config: Dict[str, Any] = {}\n    _llm_config[\"model\"] = self.name\n    for attr, atr_type in [\n        (\"base_url\", str),\n        (\"max_tokens\", int),\n        (\"temperature\", float),\n        (\"top_p\", float),\n        (\"api_version\", str),\n        (\"default_headers\", dict),\n    ]:\n        value = getattr(self.data, attr)\n        if value and isinstance(value, atr_type):\n            _llm_config[attr] = value\n    if self.data.api_type not in [\"nim\", \"other\"]:\n        _llm_config[\"api_type\"] = self.data.api_type\n    other_attrs = [\"api_key\"] if skip_price else [\"api_key\", \"price\"]\n    for attr in other_attrs:\n        value = getattr(self, attr)\n        if value:\n            _llm_config[attr] = value\n    return set_default_base_url(_llm_config, self.data.api_type)\n</code></pre>"},{"location":"models/model/#waldiez.models.model.model.WaldiezModel.price","title":"<code>price: Optional[List[float]]</code>  <code>property</code>","text":"<p>Get the model's price.</p>"},{"location":"models/model/#waldiez.models.model.model.set_default_base_url","title":"<code>set_default_base_url(llm_config: Dict[str, Any], api_type: WaldiezModelAPIType) -&gt; Dict[str, Any]</code>","text":"<p>Set the default base url if not provided.</p> <p>Parameters:</p> Name Type Description Default <code>llm_config</code> <code>Dict[str, Any]</code> <p>The llm config dictionary.</p> required <code>api_type</code> <code>str</code> <p>The api type.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The llm config dictionary with the default base url set.</p> Source code in <code>waldiez/models/model/model.py</code> <pre><code>def set_default_base_url(\n    llm_config: Dict[str, Any], api_type: WaldiezModelAPIType\n) -&gt; Dict[str, Any]:\n    \"\"\"Set the default base url if not provided.\n\n    Parameters\n    ----------\n    llm_config : Dict[str, Any]\n        The llm config dictionary.\n    api_type : str\n        The api type.\n\n    Returns\n    -------\n    Dict[str, Any]\n        The llm config dictionary with the default base url set.\n    \"\"\"\n    if api_type in (\"openai\", \"other\", \"azure\", \"cohere\"):\n        return llm_config\n    if \"base_url\" not in llm_config or not llm_config[\"base_url\"]:\n        dict_copy = llm_config.copy()\n        dict_copy[\"base_url\"] = DEFAULT_BASE_URLS.get(api_type, \"\")\n        return dict_copy\n    return llm_config\n</code></pre>"},{"location":"models/model/#waldiez.models.model.model_data.WaldiezModelData","title":"<code>WaldiezModelData</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Model Data.</p> <p>Attributes:</p> Name Type Description <code>base_url</code> <code>Optional[str]</code> <p>The base url of the model, by default None.</p> <code>api_key</code> <code>Optional[str]</code> <p>The api key to use with the model, by default None.</p> <code>api_type</code> <code>WaldiezModelAPIType</code> <p>The api type of the model.</p> <code>api_version</code> <code>Optional[str]</code> <p>The api version of the model, by default None.</p> <code>temperature</code> <code>Optional[float]</code> <p>The temperature of the model, by default None.</p> <code>top_p</code> <code>Optional[float]</code> <p>The top p of the model, by default None.</p> <code>max_tokens</code> <code>Optional[int]</code> <p>The max tokens of the model, by default None.</p> <code>default_headers</code> <code>Dict[str, str]</code> <p>The default headers of the model.</p> <code>price</code> <code>Optional[WaldiezModelPrice]</code> <p>The price of the model, by default None.</p>"},{"location":"models/model/#waldiez.models.model.model_data.WaldiezModelPrice","title":"<code>WaldiezModelPrice</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Model Price.</p> <p>Attributes:</p> Name Type Description <code>prompt_price_per_1k</code> <code>float</code> <p>The prompt price per 1k tokens.</p> <code>completion_token_price_per_1k</code> <code>float</code> <p>The completion token price per 1k tokens.</p>"},{"location":"models/skill/","title":"Skill","text":"<p>Waldiez Skill model.</p> <p>Waldiez Skill model.</p>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldiezSkill","title":"<code>WaldiezSkill</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Skill.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the skill.</p> <code>type</code> <code>Literal['skill']</code> <p>The type of the \"node\" in a graph: \"skill\".</p> <code>name</code> <code>str</code> <p>The name of the skill.</p> <code>description</code> <code>str</code> <p>The description of the skill.</p> <code>tags</code> <code>List[str]</code> <p>The tags of the skill.</p> <code>requirements</code> <code>List[str]</code> <p>The requirements of the skill.</p> <code>created_at</code> <code>str</code> <p>The date and time when the skill was created.</p> <code>updated_at</code> <code>str</code> <p>The date and time when the skill was last updated.</p> <code>data</code> <code>WaldiezSkillData</code> <p>The data of the skill. See <code>WaldiezSkillData</code>.</p>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldiezSkill.content","title":"<code>content: str</code>  <code>property</code>","text":"<p>Get the content (source) of the skill.</p>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldiezSkill.get_content","title":"<code>get_content() -&gt; str</code>","text":"<p>Get the content of the skill.</p> <p>Returns:</p> Type Description <code>str</code> <p>The content of the skill.</p> Source code in <code>waldiez/models/skill/skill.py</code> <pre><code>def get_content(self) -&gt; str:\n    \"\"\"Get the content of the skill.\n\n    Returns\n    -------\n    str\n        The content of the skill.\n    \"\"\"\n    if self.is_shared or self.is_interop:\n        return self.data.content\n    # if custom, only the function content\n    return get_function(self.data.content, self.name)\n</code></pre>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldiezSkill.get_imports","title":"<code>get_imports() -&gt; Tuple[List[str], List[str]]</code>","text":"<p>Get the skill imports.</p> <p>Returns:</p> Type Description <code>Tuple[List[str], List[str]]</code> <p>The builtin and external imports.</p> Source code in <code>waldiez/models/skill/skill.py</code> <pre><code>def get_imports(self) -&gt; Tuple[List[str], List[str]]:\n    \"\"\"Get the skill imports.\n\n    Returns\n    -------\n    Tuple[List[str], List[str]]\n        The builtin and external imports.\n    \"\"\"\n    return self._skill_imports\n</code></pre>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldiezSkill.is_interop","title":"<code>is_interop: bool</code>  <code>property</code>","text":"<p>Check if the skill is interoperability.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the skill is interoperability, False otherwise.</p>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldiezSkill.is_shared","title":"<code>is_shared: bool</code>  <code>property</code>","text":"<p>Check if the skill is shared.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the skill is shared, False otherwise.</p>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldiezSkill.load","title":"<code>load(data_or_path: Union[str, Path, Dict[str, Any]]) -&gt; WaldiezSkill</code>  <code>staticmethod</code>","text":"<p>Load a skill from a read-only file.</p> <p>Parameters:</p> Name Type Description Default <code>data_or_path</code> <code>Union[str, Path, Dict[str, Any]]</code> <p>The path to the read-only file or the loaded data.</p> required <p>Returns:</p> Type Description <code>WaldiezSkill</code> <p>The skill.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file is not found.</p> <code>ValueError</code> <p>If the JSON is invalid or the data is invalid.</p> Source code in <code>waldiez/models/skill/skill.py</code> <pre><code>@staticmethod\ndef load(data_or_path: Union[str, Path, Dict[str, Any]]) -&gt; \"WaldiezSkill\":\n    \"\"\"Load a skill from a read-only file.\n\n    Parameters\n    ----------\n    data_or_path : Union[str, Path, Dict[str, Any]]\n        The path to the read-only file or the loaded data.\n\n    Returns\n    -------\n    WaldiezSkill\n        The skill.\n\n    Raises\n    ------\n    FileNotFoundError\n        If the file is not found.\n    ValueError\n        If the JSON is invalid or the data is invalid.\n    \"\"\"\n    if isinstance(data_or_path, dict):\n        return WaldiezSkill.model_validate(data_or_path)\n    if not isinstance(data_or_path, Path):\n        data_or_path = Path(data_or_path)\n    resolved = data_or_path.resolve()\n    if not resolved.is_file():\n        raise FileNotFoundError(f\"File not found: {resolved}\")\n    with resolved.open(\"r\", encoding=\"utf-8\") as file:\n        data_string = file.read()\n        try:\n            data_dict = json.loads(data_string)\n        except BaseException as exc:  # pylint: disable=broad-except\n            raise ValueError(f\"Invalid WaldiezSkill/JSON: {exc}\") from exc\n        return WaldiezSkill.model_validate(data_dict)\n</code></pre>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldiezSkill.secrets","title":"<code>secrets: Dict[str, str]</code>  <code>property</code>","text":"<p>Get the secrets (environment variables) of the skill.</p>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldiezSkill.skill_type","title":"<code>skill_type: WaldiezSkillType</code>  <code>property</code>","text":"<p>Get the skill type.</p> <p>Returns:</p> Type Description <code>WaldiezSkillType</code> <p>The type of the skill: [shared, custom, langchain, crewai].</p>"},{"location":"models/skill/#waldiez.models.skill.skill.WaldiezSkill.validate_data","title":"<code>validate_data() -&gt; Self</code>","text":"<p>Validate the data.</p> <p>Returns:</p> Type Description <code>WaldiezSkill</code> <p>The skill.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the skill name is not in the content. If the skill content is invalid.</p> Source code in <code>waldiez/models/skill/skill.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_data(self) -&gt; Self:\n    \"\"\"Validate the data.\n\n    Returns\n    -------\n    WaldiezSkill\n        The skill.\n\n    Raises\n    ------\n    ValueError\n        If the skill name is not in the content.\n        If the skill content is invalid.\n    \"\"\"\n    self._validate_custom_skill()\n    self._validate_interop_skill()\n    self._skill_imports = gather_code_imports(\n        self.data.content, self.is_interop\n    )\n    # remove the imports from the content\n    # we 'll place them at the top of the file\n    all_imports = self._skill_imports[0] + self._skill_imports[1]\n    code_lines = self.data.content.splitlines()\n    valid_lines = [\n        line\n        for line in code_lines\n        if not any(line.startswith(imp) for imp in all_imports)\n    ]\n    # remove empty lines at the beginning and end\n    # of the content\n    while valid_lines and not valid_lines[0].strip():\n        valid_lines.pop(0)\n    while valid_lines and not valid_lines[-1].strip():\n        valid_lines.pop()\n    self.data.content = \"\\n\".join(valid_lines)\n    return self\n</code></pre>"},{"location":"models/skill/#waldiez.models.skill.skill_data.WaldiezSkillData","title":"<code>WaldiezSkillData</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Skill Data.</p> <p>Attributes:</p> Name Type Description <code>skill_type</code> <code>WaldiezSkillType</code> <p>The type of the skill: shared, custom, langchain, crewai.</p> <code>content</code> <code>str</code> <p>The content (source code) of the skill.</p> <code>secrets</code> <code>Dict[str, str]</code> <p>The secrets (environment variables) of the skill.</p>"},{"location":"models/agents/","title":"Agents","text":"<p>Waldiez agents model.</p>"},{"location":"models/agents/#waldiez.models.agents.agents.WaldiezAgents","title":"<code>WaldiezAgents</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez agents model.</p> <p>Attributes:</p> Name Type Description <code>users</code> <code>List[WaldiezUserProxy]</code> <p>User proxy agents.</p> <code>assistants</code> <code>List[WaldiezAssistant]</code> <p>Assistant agents.</p> <code>managers</code> <code>List[WaldiezGroupManager]</code> <p>Group chat managers.</p> <code>rag_users</code> <code>List[WaldiezRagUser]</code> <p>RAG user agents.</p>"},{"location":"models/agents/#waldiez.models.agents.agents.WaldiezAgents.members","title":"<code>members: Iterator[WaldiezAgent]</code>  <code>property</code>","text":"<p>Get all agents.</p> <p>Yields:</p> Type Description <code>WaldiezAgent</code> <p>The agents.</p>"},{"location":"models/agents/#waldiez.models.agents.agents.WaldiezAgents.validate_agents","title":"<code>validate_agents() -&gt; Self</code>","text":"<p>Validate the agents.</p> <ul> <li>At least two agents are required.</li> <li>All the agent IDs must be unique.</li> </ul> <p>Returns:</p> Type Description <code>WaldiezAgents</code> <p>The agents.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the agents are invalid.</p> Source code in <code>waldiez/models/agents/agents.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_agents(self) -&gt; Self:\n    \"\"\"Validate the agents.\n\n    - At least two agents are required.\n    - All the agent IDs must be unique.\n\n    Returns\n    -------\n    WaldiezAgents\n        The agents.\n\n    Raises\n    ------\n    ValueError\n        If the agents are invalid.\n    \"\"\"\n    all_agent_ids = [agent.id for agent in self.members]\n    if len(all_agent_ids) &lt; 1:\n        raise ValueError(\"At least one agent is required.\")\n    if len(all_agent_ids) != len(set(all_agent_ids)):\n        raise ValueError(\"Agent IDs must be unique.\")\n    return self\n</code></pre>"},{"location":"models/agents/#waldiez.models.agents.agents.WaldiezAgents.validate_flow","title":"<code>validate_flow(model_ids: List[str], skill_ids: List[str]) -&gt; None</code>","text":"<p>Validate the flow of the agents.</p> <ul> <li>Validate the linked models (the referenced model ids must exist).</li> <li>Validate the linked skills (the referenced skill ids must exist).</li> <li>Validate the code execution (the referenced functions must exist).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model_ids</code> <code>List[str]</code> <p>The list of model IDs.</p> required <code>skill_ids</code> <code>List[str]</code> <p>The list of skill IDs.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the flow is invalid.</p> Source code in <code>waldiez/models/agents/agents.py</code> <pre><code>def validate_flow(self, model_ids: List[str], skill_ids: List[str]) -&gt; None:\n    \"\"\"Validate the flow of the agents.\n\n    - Validate the linked models (the referenced model ids must exist).\n    - Validate the linked skills (the referenced skill ids must exist).\n    - Validate the code execution (the referenced functions must exist).\n\n    Parameters\n    ----------\n    model_ids : List[str]\n        The list of model IDs.\n    skill_ids : List[str]\n        The list of skill IDs.\n\n    Raises\n    ------\n    ValueError\n        If the flow is invalid.\n    \"\"\"\n    all_agent_ids = [agent.id for agent in self.members]\n    for agent in self.members:\n        agent.validate_linked_models(model_ids)\n        agent.validate_linked_skills(skill_ids, agent_ids=all_agent_ids)\n        agent.validate_code_execution(skill_ids=skill_ids)\n        if agent.agent_type == \"manager\" and isinstance(\n            agent, WaldiezGroupManager\n        ):\n            agent.validate_transitions(agent_ids=all_agent_ids)\n</code></pre>"},{"location":"models/agents/agent/","title":"Agent","text":"<p>Base agent class to be inherited by all agents.</p> <p>Common data structures for agents.</p> <p>Waldiez Agent Code Execution Configuration.</p> <p>Waldiez Agent Skill Model.</p> <p>Waldiez Agent Nested Chat.</p> <p>Waldiez Agent Termination Message Check.</p> <p>Waldiez Agent Teachability.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.agent.WaldiezAgent","title":"<code>WaldiezAgent</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Agent.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the agent.</p> <code>type</code> <code>Literal['agent']</code> <p>The type of the \"node\" in a graph: \"agent\"</p> <code>agent_type</code> <code>WaldiezAgentType</code> <p>The type of the agent</p> <code>name</code> <code>str</code> <p>The name of the agent.</p> <code>description</code> <code>str</code> <p>The description of the agent.</p> <code>tags</code> <code>List[str]</code> <p>Tags for this agent.</p> <code>requirements</code> <code>List[str]</code> <p>Python requirements for the agent.</p> <code>created_at</code> <code>str</code> <p>The date and time when the agent was created.</p> <code>updated_at</code> <code>str</code> <p>The date and time when the agent was last updated.</p> <code>data</code> <code>WaldiezAgentData</code> <p>The data (properties) of this agent. See <code>waldiez.models.agents.WaldiezAgentData</code> for more info.</p> <p>Methods:</p> Name Description <code>validate_linked_skills</code> <p>Validate the skills linked to the agent.</p> <code>validate_linked_models</code> <p>Validate the models linked to the agent.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.agent.WaldiezAgent.ag2_class","title":"<code>ag2_class: str</code>  <code>property</code>","text":"<p>Return the AG2 class of the agent.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.agent.WaldiezAgent.ag2_imports","title":"<code>ag2_imports: Set[str]</code>  <code>property</code>","text":"<p>Return the AG2 imports of the agent.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.agent.WaldiezAgent.validate_code_execution","title":"<code>validate_code_execution(skill_ids: List[str]) -&gt; None</code>","text":"<p>Validate the code execution config.</p> <p>Parameters:</p> Name Type Description Default <code>skill_ids</code> <code>List[str]</code> <p>The list of skill IDs.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a function is not found</p> Source code in <code>waldiez/models/agents/agent/agent.py</code> <pre><code>def validate_code_execution(self, skill_ids: List[str]) -&gt; None:\n    \"\"\"Validate the code execution config.\n\n    Parameters\n    ----------\n    skill_ids : List[str]\n        The list of skill IDs.\n\n    Raises\n    ------\n    ValueError\n        If a function is not found\n    \"\"\"\n    # if the config dict has functions, make sure they can be found\n    if isinstance(\n        self.data.code_execution_config, WaldiezAgentCodeExecutionConfig\n    ):\n        for function in self.data.code_execution_config.functions:\n            if function not in skill_ids:\n                raise ValueError(\n                    f\"Function '{function}' not found in skills\"\n                )\n</code></pre>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.agent.WaldiezAgent.validate_linked_models","title":"<code>validate_linked_models(model_ids: List[str]) -&gt; None</code>","text":"<p>Validate the models.</p> <p>Parameters:</p> Name Type Description Default <code>model_ids</code> <code>List[str]</code> <p>The list of model IDs.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a model is not found</p> Source code in <code>waldiez/models/agents/agent/agent.py</code> <pre><code>def validate_linked_models(self, model_ids: List[str]) -&gt; None:\n    \"\"\"Validate the models.\n\n    Parameters\n    ----------\n    model_ids : List[str]\n        The list of model IDs.\n\n    Raises\n    ------\n    ValueError\n        If a model is not found\n    \"\"\"\n    # if the config dict has models, make sure they can be found\n    for model in self.data.model_ids:\n        if model not in model_ids:\n            raise ValueError(\n                f\"Model '{model}' not found in agent's {self.id} models\"\n            )\n</code></pre>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.agent.WaldiezAgent.validate_linked_skills","title":"<code>validate_linked_skills(skill_ids: List[str], agent_ids: List[str]) -&gt; None</code>","text":"<p>Validate the skills.</p> <p>Parameters:</p> Name Type Description Default <code>skill_ids</code> <code>List[str]</code> <p>The list of skill IDs.</p> required <code>agent_ids</code> <code>List[str]</code> <p>The list of agent IDs.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a skill or agent is not found</p> Source code in <code>waldiez/models/agents/agent/agent.py</code> <pre><code>def validate_linked_skills(\n    self, skill_ids: List[str], agent_ids: List[str]\n) -&gt; None:\n    \"\"\"Validate the skills.\n\n    Parameters\n    ----------\n    skill_ids : List[str]\n        The list of skill IDs.\n    agent_ids : List[str]\n        The list of agent IDs.\n\n    Raises\n    ------\n    ValueError\n        If a skill or agent is not found\n    \"\"\"\n    # if the config dict has skills, make sure they can be found\n    for skill in self.data.skills:\n        if skill.id not in skill_ids:\n            raise ValueError(\n                f\"Skill '{skill.id}' not found in agent's {self.id} skills\"\n            )\n        if skill.executor_id not in agent_ids:\n            raise ValueError(\n                f\"Agent '{skill.executor_id}' not found in agents\"\n            )\n</code></pre>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.agent_data.WaldiezAgentData","title":"<code>WaldiezAgentData</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Agent Data.</p> <p>Attributes:</p> Name Type Description <code>system_message</code> <code>Optional[str]</code> <p>The agent's system message. Default: None (depends on the agent's type)</p> <code>human_input_mode</code> <code>Literal['ALWAYS', 'NEVER', 'TERMINATE']</code> <p>The human input mode to use for the agent.</p> <code>code_execution_config</code> <code>Union[WaldiezAgentCodeExecutionConfig, False]</code> <p>The code execution config. Either False (no execution) or a dict.</p> <code>agent_default_auto_reply</code> <code>Optional[str]</code> <p>The agent's default auto reply when no input is received.</p> <code>max_consecutive_auto_reply</code> <code>Optional[int]</code> <p>The maximum number or consecutive auto replies to use before ending the chat. Default: None (no limit).</p> <code>termination</code> <code>WaldiezAgentTerminationMessage</code> <p>The message termination check to use (keyword, method, none)</p> <code>teachability</code> <code>WaldiezAgentTeachability</code> <p>The agent teachability configuration.</p> <code>model_ids</code> <code>List[str]</code> <p>A list of models (their ids) to link with the agent.</p> <code>skills</code> <code>List[WaldiezAgentLinkedSkill]</code> <p>A list of skills (id and executor) to register.</p> <code>nested_chats</code> <code>List[WaldiezAgentNestedChat]</code> <p>A list of nested chats (triggered_by, messages), to register.</p> <code>is_multimodal</code> <code>bool</code> <p>A flag to indicate if the agent is multimodal.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.code_execution.WaldiezAgentCodeExecutionConfig","title":"<code>WaldiezAgentCodeExecutionConfig</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Agent Code Execution Configuration.</p> <p>Attributes:</p> Name Type Description <code>work_dir</code> <code>Optional[str]</code> <p>The working directory for the code execution.</p> <code>use_docker</code> <code>Optional[bool]</code> <p>Run the code in a docker container.</p> <code>timeout</code> <code>Optional[float]</code> <p>The timeout for the code execution. By default None (no timeout).</p> <code>last_n_messages</code> <code>Optional[int]</code> <p>The chat's last n messages to consider for the code execution.</p> <code>functions</code> <code>Optional[List[str]]</code> <p>If not using docker, a list of function ids to use.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.linked_skill.WaldiezAgentLinkedSkill","title":"<code>WaldiezAgentLinkedSkill</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Agent Linked Skill.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The id of the skill to use.</p> <code>executor_id</code> <code>str</code> <p>The id of the agent to use that skill.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.nested_chat.WaldiezAgentNestedChat","title":"<code>WaldiezAgentNestedChat</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Agent Nested Chat.</p> <p>Attributes:</p> Name Type Description <code>triggered_by</code> <code>List[str]</code> <p>A list of agent ids that trigger the nested chat.</p> <code>messages</code> <code>List[WaldiezAgentNestedChatMessage]</code> <p>The list of messages (chat ids and 'is_reply'z) to include the in the nested chat registration.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.nested_chat.WaldiezAgentNestedChatMessage","title":"<code>WaldiezAgentNestedChatMessage</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Agent nested chat message.</p> <p>A reference to a chat's message or reply in a nested chat</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The id of the chat.</p> <code>is_reply</code> <code>bool</code> <p>Whether to use the reply in the chat or not.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.termination_message.WaldiezAgentTerminationMessage","title":"<code>WaldiezAgentTerminationMessage</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Agent Termination Message Check.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['none', 'keyword', 'method']</code> <p>The type of the termination check to use: \"none\", \"keyword\", \"method\"</p> <code>keywords</code> <code>List[str]</code> <p>If the type is \"keyword\", the keywords to search in the message.</p> <code>criterion</code> <code>Optional[Literal[\"found\", \"ending\", \"exact\"]] = None</code> <p>If the type is \"keyword\", the criterion to use (e.g.: in, endswith, ==)</p> <code>method_content</code> <code>Optional[str]</code> <p>If the type is \"method\", the code of the method to use. The method must be called <code>is_termination_message</code>, have one argument (<code>message</code>) which is a dict, and return a bool (whether the message is a termination message or not.)</p> <code>string</code> <code>str</code> <p>The value of the termination message.</p> <p>Methods:</p> Name Description <code>validate_termination_message</code> <p>Validate the termination message configuration.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.termination_message.WaldiezAgentTerminationMessage.get_termination_function","title":"<code>get_termination_function(name_prefix: Optional[str] = None, name_suffix: Optional[str] = None) -&gt; Tuple[str, str]</code>","text":"<p>Get the termination function.</p> <p>Parameters:</p> Name Type Description Default <code>name_prefix</code> <code>str</code> <p>The function name prefix.</p> <code>None</code> <code>name_suffix</code> <code>str</code> <p>The function name suffix.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The termination function and the function name.</p> Source code in <code>waldiez/models/agents/agent/termination_message.py</code> <pre><code>def get_termination_function(\n    self,\n    name_prefix: Optional[str] = None,\n    name_suffix: Optional[str] = None,\n) -&gt; Tuple[str, str]:\n    \"\"\"Get the termination function.\n\n    Parameters\n    ----------\n    name_prefix : str\n        The function name prefix.\n    name_suffix : str\n        The function name suffix.\n\n    Returns\n    -------\n    Tuple[str, str]\n        The termination function and the function name.\n    \"\"\"\n    function_name = \"is_termination_message\"\n    if name_prefix:\n        function_name = f\"{name_prefix}_{function_name}\"\n    if name_suffix:\n        function_name = f\"{function_name}_{name_suffix}\"\n    if self.type in (\"none\", \"keyword\"):\n        return self.string, function_name\n    return (\n        generate_function(\n            function_name=function_name,\n            function_args=IS_TERMINATION_MESSAGE_ARGS,\n            function_types=IS_TERMINATION_MESSAGE_TYPES,\n            function_body=self.string,\n        ),\n        function_name,\n    )\n</code></pre>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.termination_message.WaldiezAgentTerminationMessage.string","title":"<code>string: str</code>  <code>property</code>","text":"<p>Get the value of the termination message.</p> <ul> <li>If the type is \"none\", the value is \"None\".</li> <li>If the type is \"keyword\", the value is a lambda function that checks     if any of the keywords comply with the criterion.</li> <li>If the type is \"method\", the value is the method content.</li> </ul> <p>Returns:</p> Type Description <code>str</code> <p>The value of the termination message.</p>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.termination_message.WaldiezAgentTerminationMessage.validate_termination_message","title":"<code>validate_termination_message() -&gt; Self</code>","text":"<p>Validate the termination message configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configuration is invalid.</p> <p>Returns:</p> Type Description <code>WaldiezAgentTerminationMessage</code> <p>The validated termination message configuration.</p> Source code in <code>waldiez/models/agents/agent/termination_message.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_termination_message(self) -&gt; Self:\n    \"\"\"Validate the termination message configuration.\n\n    Raises\n    ------\n    ValueError\n        If the configuration is invalid.\n    Returns\n    -------\n    WaldiezAgentTerminationMessage\n        The validated termination message configuration.\n    \"\"\"\n    if self.type == \"method\":\n        self._validate_method_content()\n    if self.type == \"keyword\":\n        self._validate_keyword()\n    if self.type == \"none\":\n        self._string = \"None\"\n    return self\n</code></pre>"},{"location":"models/agents/agent/#waldiez.models.agents.agent.teachability.WaldiezAgentTeachability","title":"<code>WaldiezAgentTeachability</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Waldiez Agent Teachability.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Whether the teachability is enabled.</p> <code>verbosity</code> <code>Literal[0, 1, 2, 3]</code> <p>The verbosity level of the teachability. Default: 0</p> <code>reset_db</code> <code>bool</code> <p>Whether to reset the database. Default: False</p> <code>recall_threshold</code> <code>float</code> <p>The recall threshold. Default: 1.5</p> <code>max_num_retrievals</code> <code>int</code> <p>The maximum number of retrievals. Default: 10</p>"},{"location":"models/agents/assistant/","title":"Assistant","text":"<p>Assistant agent model.</p> <p>Assistant agent data model.</p>"},{"location":"models/agents/assistant/#waldiez.models.agents.assistant.assistant.WaldiezAssistant","title":"<code>WaldiezAssistant</code>","text":"<p>               Bases: <code>WaldiezAgent</code></p> <p>Assistant agent model.</p> <p>A <code>WaldiezAgent</code> with agent_type <code>assistant</code> and default <code>human_input_mode</code>: <code>\"NEVER\"</code> See <code>WaldiezAgent</code>,<code>WaldiezAssistantData</code>,<code>WaldiezAgentData</code> for more info.</p> <p>Attributes:</p> Name Type Description <code>agent_type</code> <code>Literal['assistant']</code> <p>The agent type: 'assistant' for an assistant agent</p> <code>data</code> <code>WaldiezAssistantData</code> <p>The assistant agent's data</p>"},{"location":"models/agents/assistant/#waldiez.models.agents.assistant.assistant_data.WaldiezAssistantData","title":"<code>WaldiezAssistantData</code>","text":"<p>               Bases: <code>WaldiezAgentData</code></p> <p>Assistant agent data class.</p> <p>The data for an agent with <code>human_input_mode</code> set to <code>\"ALWAYS\"</code> as default. See the parent's docs (<code>WaldiezAgentData</code>) for the rest of the properties.</p> <p>Attributes:</p> Name Type Description <code>human_input_mode</code> <code>Literal['ALWAYS', 'NEVER', 'TERMINATE']</code> <p>The human input mode, Defaults to <code>NEVER</code></p>"},{"location":"models/agents/group_manager/","title":"GroupManager","text":"<p>Group chat manager agent.</p> <p>Group chat manager data.</p> <p>Group chat speakers.</p>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.group_manager.WaldiezGroupManager","title":"<code>WaldiezGroupManager</code>","text":"<p>               Bases: <code>WaldiezAgent</code></p> <p>Group chat manager agent.</p> <p>A <code>WaldiezAgent</code> with agent_type <code>manager</code>, <code>human_input_mode</code>: <code>\"NEVER\"</code> and chat group related config for the agent. Also see <code>WaldiezAgent</code>, <code>WaldiezGroupManagerData</code>, <code>WaldiezAgentData</code></p> <p>Attributes:</p> Name Type Description <code>agent_type</code> <code>Literal['manager']</code> <p>The agent type: 'manager' for a group manager agent</p> <code>data</code> <code>WaldiezGroupManagerData</code> <p>The group manager agent's data.</p> <p>Methods:</p> Name Description <code>validate_transitions</code> <p>Validate the transitions.</p>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.group_manager.WaldiezGroupManager.validate_transitions","title":"<code>validate_transitions(agent_ids: List[str]) -&gt; None</code>","text":"<p>Validate the transitions.</p> <p>If the selection mode is <code>transition</code>:</p> <ul> <li>if <code>allow_repeat</code> is a list of agent_ids,         make sure these ids exist.</li> <li>make sure the <code>allowed_or_disallowed_transitions</code> mapping         has valid agent ids.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>agent_ids</code> <code>List[str]</code> <p>The list of agent IDs.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the transitions are invalid.</p> Source code in <code>waldiez/models/agents/group_manager/group_manager.py</code> <pre><code>def validate_transitions(self, agent_ids: List[str]) -&gt; None:\n    \"\"\"Validate the transitions.\n\n    If the selection mode is `transition`:\n\n    - if `allow_repeat` is a list of agent_ids,\n            make sure these ids exist.\n    - make sure the `allowed_or_disallowed_transitions` mapping\n            has valid agent ids.\n\n    Parameters\n    ----------\n    agent_ids : List[str]\n        The list of agent IDs.\n\n    Raises\n    ------\n    ValueError\n        If the transitions are invalid.\n    \"\"\"\n    speakers: WaldiezGroupManagerSpeakers = self.data.speakers\n    if speakers.selection_mode != \"transition\":\n        return\n    allow_repeat = speakers.allow_repeat\n    if isinstance(allow_repeat, list):\n        for agent_id in allow_repeat:\n            if agent_id not in agent_ids:\n                raise ValueError(f\"Invalid agent id: {agent_id}\")\n    for (\n        agent_id,\n        transitions,\n    ) in speakers.allowed_or_disallowed_transitions.items():\n        if agent_id not in agent_ids:\n            raise ValueError(f\"Invalid agent id: {agent_id}\")\n        for agent_id in transitions:\n            if agent_id not in agent_ids:\n                raise ValueError(f\"Invalid agent id: {agent_id}\")\n</code></pre>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.group_manager_data.WaldiezGroupManagerData","title":"<code>WaldiezGroupManagerData</code>","text":"<p>               Bases: <code>WaldiezAgentData</code></p> <p>Group chat manager data class.</p> <p>The data for an agent with <code>human_input_mode</code> set to \"NEVER\" as default. and the chat group's related extra properties. See the parent's docs (<code>WaldiezAgentData</code>) for the rest of the properties.</p> <p>Attributes:</p> Name Type Description <code>human_input_mode</code> <code>Literal['ALWAYS', 'NEVER', 'TERMINATE']</code> <p>The human input mode, Defaults to <code>NEVER</code></p> <code>max_round</code> <code>Optional[int]</code> <p>The maximum number of rounds to have in the group.</p> <code>admin_name</code> <code>Optional[str]</code> <p>The name of the group's admin. Make sure you use a name of an agent in the group.</p> <code>speakers</code> <code>WaldiezGroupManagerSpeakers</code> <p>The rules for the speaker selection and repetition</p> <code>enable_clear_history</code> <code>Optional[bool]</code> <p>Enable clearing the history in the chat group.</p> <code>send_introductions</code> <code>bool</code> <p>Send the group members' introductions.</p>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.speakers.WaldiezGroupManagerSpeakers","title":"<code>WaldiezGroupManagerSpeakers</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Group chat speakers.</p> <p>If the method for the speaker selection is <code>custom</code> the <code>selection_custom_method</code> contents (source code) will be used. The method must be called <code>custom_speaker_selection</code>, have two arguments:</p> <ul> <li>last_speaker: <code>autogen.ConversableAgent</code></li> <li>groupchat: <code>autogen.GroupChat</code></li> </ul> <p>and return a <code>Union[Agent, str, None]</code></p> Example <pre><code>{\n    \"selectionMethod\": \"custom\",\n    \"selectionCustomMethod\": (\n        \"def custom_speaker_selection(last_speaker, groupchat):\\n\"\n        \"    return last_speaker\"\n    ),\n    ...\n}\n</code></pre> <p>Attributes:</p> Name Type Description <code>selection_method</code> <code>WaldiezGroupManagerSpeakersSelectionMethod</code> <p>The next speaker selection method.</p> <code>selection_custom_method</code> <code>Optional[str]</code> <p>Method for custom selection.</p> <code>max_retries_for_selecting</code> <code>Optional[int]</code> <p>Max retries for selecting a speaker.</p> <code>selection_mode</code> <code>WaldiezGroupManagerSpeakersSelectionMode</code> <p>Selection mode.</p> <code>allow_repeat</code> <code>Union[bool, List[str]]</code> <p>Allow repeat.</p> <code>allowed_or_disallowed_transitions</code> <code>Dict[str, List[str]]</code> <p>Allowed or disallowed transitions.</p> <code>transitions_type</code> <code>WaldiezGroupManagerSpeakersTransitionsType</code> <p>The type of transition rules to use if if a mapping (agent =&gt; List[agents]) is used: <code>allowed</code> (default) or <code>disallowed</code></p> <code>custom_method_string</code> <code>Optional[str]</code> <p>The custom method string.</p> <p>Methods:</p> Name Description <code>validate_group_speakers_config</code> <p>Validate the speakers config.</p>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.speakers.WaldiezGroupManagerSpeakers.custom_method_string","title":"<code>custom_method_string: Optional[str]</code>  <code>property</code>","text":"<p>Get the custom method string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The custom method string.</p>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.speakers.WaldiezGroupManagerSpeakers.get_custom_method_function","title":"<code>get_custom_method_function(name_prefix: Optional[str] = None, name_suffix: Optional[str] = None) -&gt; Tuple[str, str]</code>","text":"<p>Get the custom method function.</p> <p>Parameters:</p> Name Type Description Default <code>name_prefix</code> <code>str</code> <p>The function name prefix.</p> <code>None</code> <code>name_suffix</code> <code>str</code> <p>The function name suffix.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The custom method function and the function name.</p> Source code in <code>waldiez/models/agents/group_manager/speakers.py</code> <pre><code>def get_custom_method_function(\n    self,\n    name_prefix: Optional[str] = None,\n    name_suffix: Optional[str] = None,\n) -&gt; Tuple[str, str]:\n    \"\"\"Get the custom method function.\n\n    Parameters\n    ----------\n    name_prefix : str\n        The function name prefix.\n    name_suffix : str\n        The function name suffix.\n\n    Returns\n    -------\n    Tuple[str, str]\n        The custom method function and the function name.\n    \"\"\"\n    function_name = CUSTOM_SPEAKER_SELECTION\n    if name_prefix:\n        function_name = f\"{name_prefix}_{function_name}\"\n    if name_suffix:\n        function_name = f\"{function_name}_{name_suffix}\"\n    return (\n        generate_function(\n            function_name=function_name,\n            function_args=CUSTOM_SPEAKER_SELECTION_ARGS,\n            function_types=CUSTOM_SPEAKER_SELECTION_TYPES,\n            function_body=self.custom_method_string or \"\",\n        ),\n        function_name,\n    )\n</code></pre>"},{"location":"models/agents/group_manager/#waldiez.models.agents.group_manager.speakers.WaldiezGroupManagerSpeakers.validate_group_speakers_config","title":"<code>validate_group_speakers_config() -&gt; Self</code>","text":"<p>Validate the speakers config.</p> <p>Returns:</p> Type Description <code>GroupManagerSpeakers</code> <p>The group manager speakers config.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the custom method is invalid.</p> Source code in <code>waldiez/models/agents/group_manager/speakers.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_group_speakers_config(self) -&gt; Self:\n    \"\"\"Validate the speakers config.\n\n    Returns\n    -------\n    GroupManagerSpeakers\n        The group manager speakers config.\n\n    Raises\n    ------\n    ValueError\n        If the custom method is invalid.\n    \"\"\"\n    if self.selection_method == \"custom\":\n        if not self.selection_custom_method:\n            raise ValueError(\"No custom method provided.\")\n        is_valid, error_or_body = check_function(\n            code_string=self.selection_custom_method,\n            function_name=CUSTOM_SPEAKER_SELECTION,\n            function_args=CUSTOM_SPEAKER_SELECTION_ARGS,\n        )\n        if not is_valid or not error_or_body:\n            # pylint: disable=inconsistent-quotes\n            raise ValueError(\n                f\"Invalid custom method: {error_or_body or 'no content'}\"\n            )\n        self._custom_method_string = error_or_body\n    return self\n</code></pre>"},{"location":"models/agents/rag_user/","title":"RagUser","text":"<p>RAG user agent.</p> <p>It extends a user agent and has RAG related parameters (<code>retrieve_config</code>).</p> <p>Waldiez RAG user agent data.</p> <p>RAG user agent retrieve config.</p> <p>The vector db config for the RAG user agent.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.rag_user.WaldiezRagUser","title":"<code>WaldiezRagUser</code>","text":"<p>               Bases: <code>WaldiezAgent</code></p> <p>RAG user agent.</p> <p>It extends a user agent and has RAG related parameters.</p> <p>Attributes:</p> Name Type Description <code>agent_type</code> <code>Literal['rag_user']</code> <p>The agent type: 'rag_user' for a RAG user agent.</p> <code>data</code> <code>WaldiezRagUserData</code> <p>The RAG user agent's data. See <code>WaldiezRagUserData</code> for more info.</p> <code>retrieve_config</code> <code>WaldiezRagUserRetrieveConfig</code> <p>The RAG user agent's retrieve config.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.rag_user.WaldiezRagUser.retrieve_config","title":"<code>retrieve_config: WaldiezRagUserRetrieveConfig</code>  <code>property</code>","text":"<p>Get the retrieve config.</p> <p>Returns:</p> Type Description <code>WaldiezRagUserRetrieveConfig</code> <p>The RAG user agent's retrieve config.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.rag_user_data.WaldiezRagUserData","title":"<code>WaldiezRagUserData</code>","text":"<p>               Bases: <code>WaldiezUserProxyData</code></p> <p>RAG user agent data.</p> <p>The data for a RAG user agent.</p> <p>Attributes:</p> Name Type Description <code>use_message_generator</code> <code>bool</code> <p>Whether to use the message generator in user's chats. Defaults to False.</p> <code>retrieve_config</code> <code>WaldiezRagUserRetrieveConfig</code> <p>The RAG user agent's retrieve config.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldiezRagUserRetrieveConfig","title":"<code>WaldiezRagUserRetrieveConfig</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>RAG user agent.</p> <p>Attributes:</p> Name Type Description <code>task</code> <code>Literal['code', 'qa', 'default']</code> <p>The task of the retrieve chat. Possible values are 'code', 'qa' and 'default'. System prompt will be different for different tasks. The default value is default, which supports both code and qa, and provides source information in the end of the response.</p> <code>vector_db</code> <code>Literal['chroma', 'pgvector', 'mongodb', 'qdrant']</code> <p>The vector db for the retrieve chat.</p> <code>db_config</code> <code>Annotated[WaldiezVectorDbConfig, Field]</code> <p>The config for the selected vector db.</p> <code>docs_path</code> <code>Optional[Union[str, List[str]]]</code> <p>The path to the docs directory. It can also be the path to a single file, the url to a single file or a list of directories, files and urls. Default is None, which works only if the collection is already created.</p> <code>new_docs</code> <code>bool</code> <p>When True, only adds new documents to the collection; when False, updates existing documents and adds new ones. Default is True. Document id is used to determine if a document is new or existing. By default, the id is the hash value of the content.</p> <code>model</code> <code>Optional[str]</code> <p>The model to use for the retrieve chat. If key not provided, a default model gpt-4 will be used.</p> <code>chunk_token_size</code> <code>Optional[int]</code> <p>The chunk token size for the retrieve chat. If key not provided, a default size max_tokens * 0.4 will be used.</p> <code>context_max_tokens</code> <code>Optional[int]</code> <p>The context max token size for the retrieve chat. If key not provided, a default size max_tokens * 0.8 will be used.</p> <code>chunk_mode</code> <code>Optional[str]</code> <p>The chunk mode for the retrieve chat. Possible values are 'multi_lines' and 'one_line'. If key not provided, a default mode multi_lines will be used.</p> <code>must_break_at_empty_line</code> <code>bool</code> <p>Chunk will only break at empty line if True. Default is True. If chunk_mode is 'one_line', this parameter will be ignored.</p> <code>use_custom_embedding</code> <code>bool</code> <p>Whether to use custom embedding for the retrieve chat. Default is False. If True, the embedding_function should be provided.</p> <code>embedding_function</code> <code>Optional[str]</code> <p>The embedding function for creating the vector db. Default is None, SentenceTransformer with the given embedding_model will be used. If you want to use OpenAI, Cohere, HuggingFace or other embedding functions, you can pass it here, follow the examples in https://docs.trychroma.com/guides/embeddings.</p> <code>customized_prompt</code> <code>Optional[str]</code> <p>The customized prompt for the retrieve chat. Default is None.</p> <code>customized_answer_prefix</code> <code>Optional[str]</code> <p>The customized answer prefix for the retrieve chat. Default is ''. If not '' and the customized_answer_prefix is not in the answer, Update Context will be triggered.</p> <code>update_context</code> <code>bool</code> <p>If False, will not apply Update Context for interactive retrieval. Default is True.</p> <code>collection_name</code> <code>Optional[str]</code> <p>The name of the collection. If key not provided, a default name autogen-docs will be used.</p> <code>get_or_create</code> <code>bool</code> <p>Whether to get the collection if it exists. Default is False.</p> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the collection if it exists. Default is False. Case 1. if the collection does not exist, create the collection. Case 2. the collection exists, if overwrite is True, it will overwrite the collection. Case 3. the collection exists and overwrite is False, if get_or_create is True, it will get the collection, otherwise it raise a ValueError.</p> <code>use_custom_token_count</code> <code>bool</code> <p>Whether to use custom token count function for the retrieve chat. Default is False. If True, the custom_token_count_function should be provided.</p> <code>custom_token_count_function</code> <code>Optional[str]</code> <p>A custom function to count the number of tokens in a string. The function should take (text:str, model:str) as input and return the token_count(int). the retrieve_config['model'] will be passed in the function. Default is autogen.token_count_utils.count_token that uses tiktoken, which may not be accurate for non-OpenAI models.</p> <code>use_custom_text_split</code> <code>bool</code> <p>Whether to use custom text split function for the retrieve chat. Default is False. If True, the custom_text_split_function should be provided.</p> <code>custom_text_split_function</code> <code>Optional[str]</code> <p>A custom function to split a string into a list of strings. Default is None, will use the default function in autogen.retrieve_utils. split_text_to_chunks.</p> <code>custom_text_types</code> <code>Optional[List[str]]</code> <p>A list of file types to be processed. Default is autogen.retrieve_utils. TEXT_FORMATS. This only applies to files under the directories in docs_path. Explicitly included files and urls will be chunked regardless of their types.</p> <code>recursive</code> <code>bool</code> <p>Whether to search documents recursively in the docs_path. Default is True.</p> <code>distance_threshold</code> <code>float</code> <p>The threshold for the distance score, only distance smaller than it will be returned. Will be ignored if &lt; 0. Default is -1.</p> <code>embedding_function_string</code> <code>Optional[str]</code> <p>The embedding function string (if use_custom_embedding is True).</p> <code>token_count_function_string</code> <code>Optional[str]</code> <p>The token count function string (if use_custom_token_count is True).</p> <code>text_split_function_string</code> <code>Optional[str]</code> <p>The text split function string (if use_custom_text_split is True).</p> <code>n_results</code> <code>Optional[int]</code> <p>The number of results to return. Default is None, which will return all</p> <p>Methods:</p> Name Description <code>validate_custom_embedding_function</code> <p>Validate the custom embedding function.</p> <code>validate_custom_token_count_function</code> <p>Validate the custom token count function.</p> <code>validate_custom_text_split_function</code> <p>Validate the custom text split function.</p> <code>validate_rag_user_data</code> <p>Validate the RAG user data.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldiezRagUserRetrieveConfig.embedding_function_string","title":"<code>embedding_function_string: Optional[str]</code>  <code>property</code>","text":"<p>Get the embedding function string.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The embedding function string.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldiezRagUserRetrieveConfig.get_custom_embedding_function","title":"<code>get_custom_embedding_function(name_prefix: Optional[str] = None, name_suffix: Optional[str] = None) -&gt; Tuple[str, str]</code>","text":"<p>Generate the custom embedding function.</p> <p>Parameters:</p> Name Type Description Default <code>name_prefix</code> <code>str</code> <p>The function name prefix.</p> <code>None</code> <code>name_suffix</code> <code>str</code> <p>The function name suffix.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The custom embedding function and the function name.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def get_custom_embedding_function(\n    self,\n    name_prefix: Optional[str] = None,\n    name_suffix: Optional[str] = None,\n) -&gt; Tuple[str, str]:\n    \"\"\"Generate the custom embedding function.\n\n    Parameters\n    ----------\n    name_prefix : str\n        The function name prefix.\n    name_suffix : str\n        The function name suffix.\n\n    Returns\n    -------\n    Tuple[str, str]\n        The custom embedding function and the function name.\n    \"\"\"\n    function_name = CUSTOM_EMBEDDING_FUNCTION\n    if name_prefix:\n        function_name = f\"{name_prefix}_{function_name}\"\n    if name_suffix:\n        function_name = f\"{function_name}_{name_suffix}\"\n    return (\n        generate_function(\n            function_name=function_name,\n            function_args=CUSTOM_EMBEDDING_FUNCTION_ARGS,\n            function_types=CUSTOM_EMBEDDING_FUNCTION_TYPES,\n            function_body=self.embedding_function_string or \"\",\n        ),\n        function_name,\n    )\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldiezRagUserRetrieveConfig.get_custom_text_split_function","title":"<code>get_custom_text_split_function(name_prefix: Optional[str] = None, name_suffix: Optional[str] = None) -&gt; Tuple[str, str]</code>","text":"<p>Generate the custom text split function.</p> <p>Parameters:</p> Name Type Description Default <code>name_prefix</code> <code>str</code> <p>The function name prefix.</p> <code>None</code> <code>name_suffix</code> <code>str</code> <p>The function name suffix.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The custom text split function and the function name.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def get_custom_text_split_function(\n    self,\n    name_prefix: Optional[str] = None,\n    name_suffix: Optional[str] = None,\n) -&gt; Tuple[str, str]:\n    \"\"\"Generate the custom text split function.\n\n    Parameters\n    ----------\n    name_prefix : str\n        The function name prefix.\n    name_suffix : str\n        The function name suffix.\n\n    Returns\n    -------\n    Tuple[str, str]\n        The custom text split function and the function name.\n    \"\"\"\n    function_name = CUSTOM_TEXT_SPLIT_FUNCTION\n    if name_prefix:\n        function_name = f\"{name_prefix}_{function_name}\"\n    if name_suffix:\n        function_name = f\"{function_name}_{name_suffix}\"\n    return (\n        generate_function(\n            function_name=function_name,\n            function_args=CUSTOM_TEXT_SPLIT_FUNCTION_ARGS,\n            function_types=CUSTOM_TEXT_SPLIT_FUNCTION_TYPES,\n            function_body=self.text_split_function_string or \"\",\n        ),\n        function_name,\n    )\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldiezRagUserRetrieveConfig.get_custom_token_count_function","title":"<code>get_custom_token_count_function(name_prefix: Optional[str] = None, name_suffix: Optional[str] = None) -&gt; Tuple[str, str]</code>","text":"<p>Generate the custom token count function.</p> <p>Parameters:</p> Name Type Description Default <code>name_prefix</code> <code>str</code> <p>The function name prefix.</p> <code>None</code> <code>name_suffix</code> <code>str</code> <p>The function name suffix.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The custom token count function and the function name.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def get_custom_token_count_function(\n    self,\n    name_prefix: Optional[str] = None,\n    name_suffix: Optional[str] = None,\n) -&gt; Tuple[str, str]:\n    \"\"\"Generate the custom token count function.\n\n    Parameters\n    ----------\n    name_prefix : str\n        The function name prefix.\n    name_suffix : str\n        The function name suffix.\n\n    Returns\n    -------\n    Tuple[str, str]\n        The custom token count function and the function name.\n    \"\"\"\n    function_name = CUSTOM_TOKEN_COUNT_FUNCTION\n    if name_prefix:\n        function_name = f\"{name_prefix}_{function_name}\"\n    if name_suffix:\n        function_name = f\"{function_name}_{name_suffix}\"\n    return (\n        generate_function(\n            function_name=function_name,\n            function_args=CUSTOM_TOKEN_COUNT_FUNCTION_ARGS,\n            function_types=CUSTOM_TOKEN_COUNT_FUNCTION_TYPES,\n            function_body=self.token_count_function_string or \"\",\n        ),\n        function_name,\n    )\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldiezRagUserRetrieveConfig.text_split_function_string","title":"<code>text_split_function_string: Optional[str]</code>  <code>property</code>","text":"<p>Get the text split function string.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The text split function string.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldiezRagUserRetrieveConfig.token_count_function_string","title":"<code>token_count_function_string: Optional[str]</code>  <code>property</code>","text":"<p>Get the token count function string.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The token count function string.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldiezRagUserRetrieveConfig.validate_custom_embedding_function","title":"<code>validate_custom_embedding_function() -&gt; None</code>","text":"<p>Validate the custom embedding function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def validate_custom_embedding_function(self) -&gt; None:\n    \"\"\"Validate the custom embedding function.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if self.use_custom_embedding:\n        if not self.embedding_function:\n            raise ValueError(\n                \"The embedding_function is required \"\n                \"if use_custom_embedding is True.\"\n            )\n        valid, error_or_content = check_function(\n            code_string=self.embedding_function,\n            function_name=CUSTOM_EMBEDDING_FUNCTION,\n            function_args=CUSTOM_EMBEDDING_FUNCTION_ARGS,\n        )\n        if not valid:\n            raise ValueError(error_or_content)\n        self._embedding_function_string = error_or_content\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldiezRagUserRetrieveConfig.validate_custom_text_split_function","title":"<code>validate_custom_text_split_function() -&gt; None</code>","text":"<p>Validate the custom text split function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def validate_custom_text_split_function(self) -&gt; None:\n    \"\"\"Validate the custom text split function.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if self.use_custom_text_split:\n        if not self.custom_text_split_function:\n            raise ValueError(\n                \"The custom_text_split_function is required \"\n                \"if use_custom_text_split is True.\"\n            )\n        valid, error_or_content = check_function(\n            code_string=self.custom_text_split_function,\n            function_name=CUSTOM_TEXT_SPLIT_FUNCTION,\n            function_args=CUSTOM_TEXT_SPLIT_FUNCTION_ARGS,\n        )\n        if not valid:\n            raise ValueError(error_or_content)\n        self._text_split_function_string = error_or_content\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldiezRagUserRetrieveConfig.validate_custom_token_count_function","title":"<code>validate_custom_token_count_function() -&gt; None</code>","text":"<p>Validate the custom token count function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def validate_custom_token_count_function(self) -&gt; None:\n    \"\"\"Validate the custom token count function.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if self.use_custom_token_count:\n        if not self.custom_token_count_function:\n            raise ValueError(\n                \"The custom_token_count_function is required \"\n                \"if use_custom_token_count is True.\"\n            )\n        valid, error_or_content = check_function(\n            code_string=self.custom_token_count_function,\n            function_name=CUSTOM_TOKEN_COUNT_FUNCTION,\n            function_args=CUSTOM_TOKEN_COUNT_FUNCTION_ARGS,\n        )\n        if not valid:\n            raise ValueError(error_or_content)\n        self._token_count_function_string = error_or_content\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldiezRagUserRetrieveConfig.validate_docs_path","title":"<code>validate_docs_path() -&gt; None</code>","text":"<p>Validate the docs path.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def validate_docs_path(self) -&gt; None:\n    \"\"\"Validate the docs path.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if not self.docs_path:\n        return\n    # if urls or directories ok, if files they should resolve\n    doc_paths = (\n        [self.docs_path]\n        if isinstance(self.docs_path, str)\n        else self.docs_path\n    )\n    paths: List[str] = []\n    for path in doc_paths:\n        resolved = path\n        is_remote, is_raw = is_remote_path(resolved)\n        if is_remote:\n            if not is_raw:\n                resolved = f'r\"{resolved}\"'\n            if resolved not in paths:\n                paths.append(resolved)\n            continue\n        resolved = remove_file_scheme(resolved)\n        is_raw = resolved.startswith((\"r'\", 'r\"'))\n        maybe_folder = string_represents_folder(resolved)\n        if maybe_folder:\n            if not is_raw:\n                resolved = f'r\"{resolved}\"'\n            if resolved not in paths:\n                paths.append(resolved)\n            continue\n        resolved = resolve_path(resolved, is_raw, not maybe_folder)\n        if resolved not in paths:\n            paths.append(resolved)\n    self.docs_path = paths\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.WaldiezRagUserRetrieveConfig.validate_rag_user_data","title":"<code>validate_rag_user_data() -&gt; Self</code>","text":"<p>Validate the RAG user data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> <p>Returns:</p> Type Description <code>WaldiezRagUserData</code> <p>The validated RAG user data.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_rag_user_data(self) -&gt; Self:\n    \"\"\"Validate the RAG user data.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n\n    Returns\n    -------\n    WaldiezRagUserData\n        The validated RAG user data.\n    \"\"\"\n    self.validate_custom_embedding_function()\n    self.validate_custom_token_count_function()\n    self.validate_custom_text_split_function()\n    self.validate_docs_path()\n    if not self.db_config.model:\n        self.db_config.model = WaldiezRagUserModels[self.vector_db]\n    if isinstance(self.n_results, int) and self.n_results &lt; 1:\n        self.n_results = None\n    return self\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.is_remote_path","title":"<code>is_remote_path(path: str) -&gt; Tuple[bool, bool]</code>","text":"<p>Check if a path is a remote path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to check.</p> required <p>Returns:</p> Type Description <code>Tuple[bool, bool]</code> <p>If the path is a remote path and if it's a raw string.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def is_remote_path(path: str) -&gt; Tuple[bool, bool]:\n    \"\"\"Check if a path is a remote path.\n\n    Parameters\n    ----------\n    path : str\n        The path to check.\n\n    Returns\n    -------\n    Tuple[bool, bool]\n        If the path is a remote path and if it's a raw string.\n    \"\"\"\n    is_raw = path.startswith((\"r'\", 'r\"'))\n    for not_local in NOT_LOCAL:\n        if path.startswith((not_local, f'r\"{not_local}', f\"r'{not_local}\")):\n            return True, is_raw\n    return False, is_raw\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.remove_file_scheme","title":"<code>remove_file_scheme(path: str) -&gt; str</code>","text":"<p>Remove the file:// scheme from a path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to remove the scheme from.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The path without the scheme.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def remove_file_scheme(path: str) -&gt; str:\n    \"\"\"Remove the file:// scheme from a path.\n\n    Parameters\n    ----------\n    path : str\n        The path to remove the scheme from.\n\n    Returns\n    -------\n    str\n        The path without the scheme.\n    \"\"\"\n    resolved = str(path)\n    while resolved.startswith('r\"file://') and resolved.endswith('\"'):\n        resolved = resolved[len('r\"file://') : -1]\n    while resolved.startswith(\"r'file://\") and resolved.endswith(\"'\"):\n        resolved = resolved[len(\"r'file://\") : -1]\n    while resolved.startswith(\"file://\"):\n        resolved = resolved[len(\"file://\") :]\n    return resolved\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.resolve_path","title":"<code>resolve_path(path: str, is_raw: bool, must_exist: bool) -&gt; str</code>","text":"<p>Try to resolve a path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to resolve.</p> required <code>is_raw</code> <code>bool</code> <p>If the path is a raw string.</p> required <code>must_exist</code> <code>bool</code> <p>If the path must exist.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The resolved path.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is not a valid local path.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def resolve_path(path: str, is_raw: bool, must_exist: bool) -&gt; str:\n    \"\"\"Try to resolve a path.\n\n    Parameters\n    ----------\n    path : str\n        The path to resolve.\n    is_raw : bool\n        If the path is a raw string.\n    must_exist : bool\n        If the path must exist.\n    Returns\n    -------\n    Path\n        The resolved path.\n\n    Raises\n    ------\n    ValueError\n        If the path is not a valid local path.\n    \"\"\"\n    # pylint: disable=broad-except\n    path_string = path\n    if is_raw:\n        path_string = path[2:-1]\n    try:\n        resolved = Path(path_string).resolve()\n    except BaseException as error:  # pragma: no cover\n        # check if 'r'... is needed\n        raw_string = f'r\"{path}\"'\n        try:\n            Path(raw_string).resolve()\n        except BaseException:\n            raise ValueError(\n                f\"Path {path} is not a valid local path.\"\n            ) from error\n        return raw_string\n    if not resolved.exists() and must_exist:\n        raise ValueError(f\"Path {path} does not exist.\")\n    return f'r\"{resolved}\"'\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.retrieve_config.string_represents_folder","title":"<code>string_represents_folder(path: str) -&gt; bool</code>","text":"<p>Check if a string represents a folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The string to check (does not need to exist).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the path is likely a folder, False if it's likely a file.</p> Source code in <code>waldiez/models/agents/rag_user/retrieve_config.py</code> <pre><code>def string_represents_folder(path: str) -&gt; bool:\n    \"\"\"Check if a string represents a folder.\n\n    Parameters\n    ----------\n    path : str\n        The string to check (does not need to exist).\n\n    Returns\n    -------\n    bool\n        True if the path is likely a folder, False if it's likely a file.\n    \"\"\"\n    if path.endswith(os.path.sep):\n        return True\n    if os.path.isdir(path):\n        return True\n    return not os.path.splitext(path)[1]\n</code></pre>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.vector_db_config.WaldiezRagUserVectorDbConfig","title":"<code>WaldiezRagUserVectorDbConfig</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>The config for the vector db.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>The model to use for the vector db embeddings.</p> <code>use_memory</code> <code>bool</code> <p>Whether to use memory for the vector db (if <code>qdrant</code> is used).</p> <code>use_local_storage</code> <code>bool</code> <p>Whether to use local storage for the db (if <code>qdrant</code> or <code>chroma</code> is used).</p> <code>local_storage_path</code> <code>Optional[str]</code> <p>The path to the local storage for the vector db (if <code>qdrant</code> or <code>chroma</code> is used).</p> <code>connection_url</code> <code>Optional[str]</code> <p>The connection url for the vector db.</p> <code>wait_until_index_ready</code> <code>Optional[float]</code> <p>Blocking call to wait until the database indexes are ready (if <code>mongodb</code> is used). None, the default, means no wait.</p> <code>wait_until_document_ready</code> <code>Optional[float]</code> <p>Blocking call to wait until the database documents are ready (if <code>mongodb</code> is used). None, the default, means no wait.</p> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>The metadata to use for the vector db. Example: {\"hnsw:space\": \"ip\", \"hnsw:construction_ef\": 30, \"hnsw:M\": 32}</p> <p>Methods:</p> Name Description <code>validate_vector_db_config</code> <p>Validate the vector db config.</p>"},{"location":"models/agents/rag_user/#waldiez.models.agents.rag_user.vector_db_config.WaldiezRagUserVectorDbConfig.validate_vector_db_config","title":"<code>validate_vector_db_config() -&gt; Self</code>","text":"<p>Validate the vector db config.</p> <p>if local storage is used, make sure the path is provided, and make it absolute if not already.</p> <p>Returns:</p> Type Description <code>WaldiezRagUserVectorDbConfig</code> <p>The vector db config.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/agents/rag_user/vector_db_config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_vector_db_config(self) -&gt; Self:\n    \"\"\"Validate the vector db config.\n\n    if local storage is used, make sure the path is provided,\n    and make it absolute if not already.\n\n    Returns\n    -------\n    WaldiezRagUserVectorDbConfig\n        The vector db config.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    if self.use_local_storage:\n        if self.local_storage_path is None:\n            raise ValueError(\n                \"The local storage path must be provided if local storage is used.\"\n            )\n        as_path = Path(self.local_storage_path)\n        if not as_path.is_absolute():\n            self.local_storage_path = str(as_path.resolve())\n    return self\n</code></pre>"},{"location":"models/agents/swarm_agent/","title":"SwarmAgent","text":"<p>Swarm agent.</p> <p>Swarm agent data.</p> <p>Swarm condition model for handoff.</p> <p>Swarm after work model.</p> <p>Handles the next step in the conversation when an agent doesn't suggest a tool call or a handoff.</p> <p>Update the agent's system message before they reply.</p>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.swarm_agent.WaldiezSwarmAgent","title":"<code>WaldiezSwarmAgent</code>","text":"<p>               Bases: <code>WaldiezAgent</code></p> <p>Swarm agent.</p> <p>It extends a user agent and has swarm related parameters.</p> <p>Attributes:</p> Name Type Description <code>agent_type</code> <code>Literal['swarm']</code> <p>The agent type: 'swarm' for a swarm agent.</p> <code>data</code> <code>WaldiezSwarmAgentData</code> <p>The swarm agent's data. See <code>WaldiezSwarmAgentData</code> for more info.</p>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.swarm_agent.WaldiezSwarmAgent.functions","title":"<code>functions: List[str]</code>  <code>property</code>","text":"<p>Get the functions that the agent can use.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The functions that the agent can use.</p>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.swarm_agent.WaldiezSwarmAgent.handoffs","title":"<code>handoffs: List[Union[WaldiezSwarmOnCondition, WaldiezSwarmAfterWork]]</code>  <code>property</code>","text":"<p>Get the hand offs to register.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The hand offs to register.</p>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.swarm_agent.WaldiezSwarmAgent.is_initial","title":"<code>is_initial: bool</code>  <code>property</code>","text":"<p>Check if the agent is the initial agent.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the agent is the initial agent.</p>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.swarm_agent.WaldiezSwarmAgent.nested_chats","title":"<code>nested_chats: List[WaldiezAgentNestedChat]</code>  <code>property</code>","text":"<p>Get the nested chats.</p> <p>Returns:</p> Type Description <code>List[WaldiezChat]</code> <p>The nested chats.</p>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.swarm_agent.WaldiezSwarmAgent.update_agent_state_before_reply","title":"<code>update_agent_state_before_reply: List[Union[str, WaldiezSwarmUpdateSystemMessage]]</code>  <code>property</code>","text":"<p>Get the functions that update the agent's state before it replies.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The functions that update the agent's state before it replies.</p>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.swarm_agent_data.WaldiezSwarmAgentData","title":"<code>WaldiezSwarmAgentData</code>","text":"<p>               Bases: <code>WaldiezAgentData</code></p> <p>Swarm agent data.</p> <p>Attributes:</p> Name Type Description <code>is_initial</code> <code>bool</code> <p>Whether the agent is the initial agent.</p> <code>functions</code> <code>List[str]</code> <p>A list of functions (skill ids) to register with the agent.</p> <code>update_agent_state_before_reply</code> <code>List[str]</code> <p>A list of functions, including <code>UPDATE_SYSTEM_MESSAGE</code>, called to update the agent's state before it replies. Each function is called when the agent is selected and before it speaks.</p> <code>handoffs</code> <code>List[Union[WaldiezSwarmOnCondition, WaldiezSwarmAfterWork]]</code> <p>A list of hand offs to register.</p> Notes <p>Each agent should have at most one <code>AfterWork</code> and (if any) it should be at the end the list of hand offs.</p>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.swarm_agent_data.WaldiezSwarmAgentData.validate_handoffs","title":"<code>validate_handoffs() -&gt; Self</code>","text":"<p>Validate the hand offs.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The swarm agent data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are more than one <code>AfterWork</code>s.</p> Source code in <code>waldiez/models/agents/swarm_agent/swarm_agent_data.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_handoffs(self) -&gt; Self:\n    \"\"\"Validate the hand offs.\n\n    Returns\n    -------\n    Self\n        The swarm agent data.\n\n    Raises\n    ------\n    ValueError\n        If there are more than one `AfterWork`s.\n    \"\"\"\n    after_works: List[WaldiezSwarmAfterWork] = [\n        hand_off\n        for hand_off in self.handoffs\n        if isinstance(hand_off, WaldiezSwarmAfterWork)\n    ]\n    if len(after_works) &gt; 1:\n        raise ValueError(\n            \"Each agent should have at most one `AfterWork` \"\n            \"and (if any) it should be at the end of the list.\"\n        )\n    on_conditions: List[WaldiezSwarmOnCondition] = [\n        hand_off\n        for hand_off in self.handoffs\n        if isinstance(hand_off, WaldiezSwarmOnCondition)\n    ]\n    on_conditions = sorted(on_conditions, key=lambda x: x.target.order)\n    handoffs = on_conditions + after_works\n    self.handoffs = handoffs\n    return self\n</code></pre>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.on_condition.WaldiezSwarmOnCondition","title":"<code>WaldiezSwarmOnCondition</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Swarm condition to handle handoff.</p> <p>Attributes:</p> Name Type Description <code>target</code> <code>WaldiezSwarmOnConditionTarget</code> <p>The agent or nested chat configuration to hand off to.</p> <code>target_type</code> <code>Literal['agent', 'nested_chat']</code> <p>The type of the target. Can be either 'agent' or 'nested_chat'. Default is 'agent'.</p> <code>condition</code> <code>str</code> <p>The condition for transitioning to the target agent</p> <code>available</code> <code>(str, optional)</code> <p>Optional condition to determine if this ON_CONDITION is available. Can be a Callable or a string.  If a string, it will look up the value of the context variable with that name, which should be a bool.</p> <code>available_check_type</code> <code>Literal['string', 'callable', 'none']</code> <p>The type of the <code>available</code> property to check. Default is \"none\".</p>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.on_condition.WaldiezSwarmOnCondition.get_available","title":"<code>get_available(name_prefix: Optional[str] = None, name_suffix: Optional[str] = None) -&gt; Tuple[str, str]</code>","text":"<p>Get the available string.</p> <p>Parameters:</p> Name Type Description Default <code>name_prefix</code> <code>str</code> <p>The prefix to add to the function name. Default is None.</p> <code>None</code> <code>name_suffix</code> <code>str</code> <p>The suffix to add to the function name. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The available string or function name and code if available.</p> Source code in <code>waldiez/models/agents/swarm_agent/on_condition.py</code> <pre><code>def get_available(\n    self,\n    name_prefix: Optional[str] = None,\n    name_suffix: Optional[str] = None,\n) -&gt; Tuple[str, str]:\n    \"\"\"Get the available string.\n\n    Parameters\n    ----------\n    name_prefix : str, optional\n        The prefix to add to the function name. Default is None.\n    name_suffix : str, optional\n        The suffix to add to the function name. Default is None.\n    Returns\n    -------\n    Tuple[str, str]\n        The available string or function name and code if available.\n    \"\"\"\n    return self.available.get_available(\n        name_prefix,\n        name_suffix,\n    )\n</code></pre>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.after_work.WaldiezSwarmAfterWork","title":"<code>WaldiezSwarmAfterWork</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Swarm after work.</p> <p>Attributes:</p> Name Type Description <code>recipient</code> <code>str</code> <p>The agent_id to hand off to, an AfterWork option, or the custom after work method. If it is an AfterWork option, it can be one of ('TERMINATE', 'REVERT_TO_USER', 'STAY', 'SWARM_MANAGER').</p> <code>recipient_type</code> <code>WaldiezSwarmAfterWorkRecipientType</code> <p>The type of recipient. Can be 'agent', 'option', or 'callable'. If 'agent', the recipient is a SwarmAgent. If 'option', the recipient is an AfterWorkOption :     ('TERMINATE', 'REVERT_TO_USER', 'STAY', 'SWARM_MANAGER'). If 'callable', it should have the signature: def custom_after_work(     last_speaker: SwarmAgent,     messages: List[dict],     groupchat: GroupChat, ) -&gt; Union[AfterWorkOption, SwarmAgent, str]:</p>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.after_work.WaldiezSwarmAfterWork.get_recipient","title":"<code>get_recipient(agent_names: Dict[str, str], name_prefix: Optional[str] = None, name_suffix: Optional[str] = None) -&gt; Tuple[str, str]</code>","text":"<p>Get the recipient string.</p> <p>Parameters:</p> Name Type Description Default <code>agent_names</code> <code>Dict[str, str]</code> <p>A mapping of agent id to agent name.</p> required <code>name_prefix</code> <code>Optional[str]</code> <p>The prefix for the function name, by default None.</p> <code>None</code> <code>name_suffix</code> <code>Optional[str]</code> <p>The suffix for the function name, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The recipient string and the function content if applicable.</p> Source code in <code>waldiez/models/agents/swarm_agent/after_work.py</code> <pre><code>def get_recipient(\n    self,\n    agent_names: Dict[str, str],\n    name_prefix: Optional[str] = None,\n    name_suffix: Optional[str] = None,\n) -&gt; Tuple[str, str]:\n    \"\"\"Get the recipient string.\n\n    Parameters\n    ----------\n    agent_names : Dict[str, str]\n        A mapping of agent id to agent name.\n    name_prefix : Optional[str], optional\n        The prefix for the function name, by default None.\n    name_suffix : Optional[str], optional\n        The suffix for the function name, by default None.\n\n    Returns\n    -------\n    Tuple[str, str]\n        The recipient string and the function content if applicable.\n    \"\"\"\n    if self.recipient_type == \"option\":\n        return f\"AFTER_WORK(AfterWorkOption.{self.recipient})\", \"\"\n    if self.recipient_type == \"agent\":\n        # the the recipient is passed as the agent name\n        # (and not its id), care should be taken to ensure\n        # the all the agents in the flow have unique names\n        agent_instance = agent_names.get(self.recipient, self.recipient)\n        return f\"AFTER_WORK({agent_instance})\", \"\"\n\n    function_name = CUSTOM_AFTER_WORK\n    if name_prefix:\n        function_name = f\"{name_prefix}_{function_name}\"\n    if name_suffix:\n        function_name = f\"{function_name}_{name_suffix}\"\n    return (\n        f\"AFTER_WORK({function_name})\",\n        generate_function(\n            function_name=function_name,\n            function_args=CUSTOM_AFTER_WORK_ARGS,\n            function_body=self._recipient_string,\n            function_types=CUSTOM_AFTER_WORK_TYPES,\n        ),\n    )\n</code></pre>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.after_work.WaldiezSwarmAfterWork.validate_recipient","title":"<code>validate_recipient() -&gt; Self</code>","text":"<p>Validate the recipient.</p> <p>Returns:</p> Type Description <code>WaldiezSwarmAfterWork</code> <p>The validated after work model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the validation fails.</p> Source code in <code>waldiez/models/agents/swarm_agent/after_work.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_recipient(self) -&gt; Self:\n    \"\"\"Validate the recipient.\n\n    Returns\n    -------\n    WaldiezSwarmAfterWork\n        The validated after work model.\n\n    Raises\n    ------\n    ValueError\n        If the validation fails.\n    \"\"\"\n    self._recipient_string = self.recipient\n    if self.recipient_type == \"callable\":\n        is_valid, error_or_body = check_function(\n            code_string=self.recipient,\n            function_name=CUSTOM_AFTER_WORK,\n            function_args=CUSTOM_AFTER_WORK_ARGS,\n        )\n        if not is_valid or not error_or_body:\n            # pylint: disable=inconsistent-quotes\n            raise ValueError(\n                f\"Invalid custom method: {error_or_body or 'no content'}\"\n            )\n        self._recipient_string = error_or_body\n    elif self.recipient_type == \"option\":\n        if self.recipient not in [\n            \"TERMINATE\",\n            \"REVERT_TO_USER\",\n            \"STAY\",\n            \"SWARM_MANAGER\",\n        ]:\n            raise ValueError(\"Invalid option.\")\n    return self\n</code></pre>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.update_system_message.WaldiezSwarmUpdateSystemMessage","title":"<code>WaldiezSwarmUpdateSystemMessage</code>","text":"<p>               Bases: <code>WaldiezBase</code></p> <p>Update the agent's system message before they reply.</p> <p>Attributes:</p> Name Type Description <code>update_function_type</code> <code>Literal['string', 'callable']</code> <p>The type of the update function. Can be either a string or a callable.</p> <code>update_function</code> <code>str</code> <p>The string template or function definition to update the agent's system message. Can be a string or a Callable. If the <code>function_type</code> is 'string' it will be used as a template and substitute the context variables. If the <code>function_type</code> is 'callable', it should have the signature: <pre><code>def custom_update_system_message(\n    agent: ConversableAgent,\n    messages: List[Dict[str, Any]]\n) -&gt; str:\n</code></pre></p>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.update_system_message.WaldiezSwarmUpdateSystemMessage.get_update_function","title":"<code>get_update_function(name_prefix: Optional[str] = None, name_suffix: Optional[str] = None) -&gt; Tuple[str, str]</code>","text":"<p>Get the update function.</p> <p>Parameters:</p> Name Type Description Default <code>name_prefix</code> <code>str</code> <p>The prefix of the name, by default None</p> <code>None</code> <code>name_suffix</code> <code>str</code> <p>The suffix of the name, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The update function and the function name.</p> Source code in <code>waldiez/models/agents/swarm_agent/update_system_message.py</code> <pre><code>def get_update_function(\n    self,\n    name_prefix: Optional[str] = None,\n    name_suffix: Optional[str] = None,\n) -&gt; Tuple[str, str]:\n    \"\"\"Get the update function.\n\n    Parameters\n    ----------\n    name_prefix : str, optional\n        The prefix of the name, by default None\n    name_suffix : str, optional\n        The suffix of the name, by default None\n\n    Returns\n    -------\n    Tuple[str, str]\n        The update function and the function name.\n\n    \"\"\"\n    function_name = CUSTOM_UPDATE_SYSTEM_MESSAGE\n    if name_prefix:\n        function_name = f\"{name_prefix}_{function_name}\"\n    if name_suffix:\n        function_name = f\"{function_name}_{name_suffix}\"\n    return (\n        generate_function(\n            function_name=function_name,\n            function_args=CUSTOM_UPDATE_SYSTEM_MESSAGE_ARGS,\n            function_types=CUSTOM_UPDATE_SYSTEM_MESSAGE_TYPES,\n            function_body=self._update_function,\n        ),\n        function_name,\n    )\n</code></pre>"},{"location":"models/agents/swarm_agent/#waldiez.models.agents.swarm_agent.update_system_message.WaldiezSwarmUpdateSystemMessage.validate_update_system_message","title":"<code>validate_update_system_message() -&gt; Self</code>","text":"<p>Validate the update system message function.</p> <p>Returns:</p> Type Description <code>UpdateSystemMessage</code> <p>The validated update system message.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the type is callable and the function is invalid. or if the function type is not 'string' or 'callable'.</p> Source code in <code>waldiez/models/agents/swarm_agent/update_system_message.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_update_system_message(self) -&gt; Self:\n    \"\"\"Validate the update system message function.\n\n    Returns\n    -------\n    UpdateSystemMessage\n        The validated update system message.\n\n    Raises\n    ------\n    ValueError\n        If the type is callable and the function is invalid.\n        or if the function type is not 'string' or 'callable'.\n\n    \"\"\"\n    self._update_function = self.update_function\n    if self.update_function_type == \"callable\":\n        valid, error_or_body = check_function(\n            code_string=self.update_function,\n            function_name=CUSTOM_UPDATE_SYSTEM_MESSAGE,\n            function_args=CUSTOM_UPDATE_SYSTEM_MESSAGE_ARGS,\n        )\n        if not valid or not error_or_body:\n            # pylint: disable=inconsistent-quotes\n            raise ValueError(\n                f\"Invalid custom method: {error_or_body or 'no content'}\"\n            )\n        self._update_function = error_or_body\n    return self\n</code></pre>"},{"location":"models/agents/user_proxy/","title":"UserProxy","text":"<p>User proxy agent model.</p> <p>User proxy agent data module.</p>"},{"location":"models/agents/user_proxy/#waldiez.models.agents.user_proxy.user_proxy.WaldiezUserProxy","title":"<code>WaldiezUserProxy</code>","text":"<p>               Bases: <code>WaldiezAgent</code></p> <p>User proxy agent model.</p> <p>A <code>WaldiezAgent</code> with agent_type <code>user</code> and default <code>human_input_mode</code>: <code>\"ALWAYS\"</code> See <code>WaldiezAgent</code>,<code>WaldiezUserProxyData</code>,<code>WaldiezAgentData</code> for more info.</p> <p>Attributes:</p> Name Type Description <code>agent_type</code> <code>Literal['user']</code> <p>The agent type: 'user' for a user proxy agent</p> <code>data</code> <code>WaldiezUserProxyData</code> <p>The user proxy agent's data</p>"},{"location":"models/agents/user_proxy/#waldiez.models.agents.user_proxy.user_proxy_data.WaldiezUserProxyData","title":"<code>WaldiezUserProxyData</code>","text":"<p>               Bases: <code>WaldiezAgentData</code></p> <p>User proxy agent data class.</p> <p>The data for an agent with <code>human_input_mode</code> set to <code>\"ALWAYS\"</code> as default. See the parent's docs (<code>WaldiezAgentData</code>) for the rest of the properties.</p> <p>Attributes:</p> Name Type Description <code>human_input_mode</code> <code>Literal['ALWAYS', 'NEVER', 'TERMINATE']</code> <p>The human input mode, Defaults to <code>ALWAYS</code></p>"}]}